---------
title: 翻译spring-cloud的一篇文章
categories:
- 翻译
tags:
- 翻译
- spring-cloud
- 微服务
---------

>导读：
- 翻译：灯塔
- 校对：
- 翻译原文：http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html
- 翻译目的：玩玩这个https://github.com/kbastani/spring-cloud-microservice-example
注意：企业实现微服务化时，需要考虑团队的水平，技术成本，和当前的业务需求，业务体量，微服务实施也并不好玩，分布式会比单体架构难度大的多。
-------------------

# 什么是Spring-Cloud?
Spring-Cloud 是一套工具集合，用来提供解决方案构建分布式系统时遇到的一些常见的模式。如果你熟悉构建用spring 来构建应用，那么spring-cloud常用来构建它的一些常见的构建块。
在Spring-Cloud 提供的解决方案中，你可能要找一些工具来解决一下的一下问题：
- Configuration management（配置管理）
- Service discovery(服务发现)
- Circuit breakers（断融器）
- Distributed sessions（分布式回会话）

# Spring Boot
这里大部分spring-cloud 的工作都是基于spring-boot 的基础上的。
下面谈论的一些东西对于spring-boot来说都是一些新的东西，下面的项目名称已经很大的程度上已经说明了他是干什么的。
你能在Spring框架和spring的生态圈中的到所有的最好的东西，调到完美，以最小的配置，为生产环境做好随时发布的准备。

# 服务发现和集成路由
在为服务的架构中，每一个服务都有单独的作用。在用spring-cloud中构建微服务架构时，这里有一些概念需要首先去处理和熟悉的。第一和第二个微服务，将需要你去创建一个**配置服务**，和**发现服务**。在用spring-cloud中构建微服务架构时，这里有一些概念需要首先去处理和熟悉的。第一和第二个微服务，将需要你去创建一个**配置服务**，和**发现服务**。

![微服务](http://i.imgur.com/Dc6xjwd.png "title")

上面的图片展示了一个4-microservice设置，连线表示了它们之间的依赖。

**配置服务**，在顶部，用黄色表示，同时，它也被其他的微服务依赖。**发现服务**在低部，标记为蓝色，同时也被其他微服务依赖。

绿色，是代表2个微服务，这是这个例子的应用的一部分，我在这篇博客中叫他为 **movies** 和 **recommendations**

# 配置服务（Configuration Service）

这个**配置服务**，在所有的微服务架构中都是一个非常重要的概念，基于[twelve-factor](http://12factor.net/config)应用方法,微服务的配置应该是在环境中得到存储，而不是仅仅在项目中。

**配置服务** 是必须的，因为他为所有的微服务处理了配置，通过简单的点对点服务调用，来检索这些配置，这是多功能的优点。

让我们来总结一下，这个多个部署环境。如果我们有一个临时环境和生产环境，在这些环境中，我们的配置是不一样的，一个配置服务可能有一个专用的Git存储库的配置环境。没有其他的环境中能够访问这个配置
它是只提供给服务在该环境运行时的配置。

![微服务](http://i.imgur.com/J7FazPH.png "title")

当**配置服务**开启后，它会根据配置路劲找到配置文件，去服务那些需要配置服务的微服务程序。每一个微服务都可以拥有他们的自己的配置，来处理一些正在运行的特殊环境。
在这个过程中，配置外部化和集中在一个地方，可以版本控制和修改，而无需重启服务改变配置。

可以利用spring-cloud 的节点管理，你可以让配置环境的改变，只是需要简单的刷新 **发现服务**， 这样就能强制让全部的服务消费者发现这个新的服务。

# 发现服务(Discovery Service)
**发现服务**是微服务架构中的另外一个重要的组件。**发现服务**处理维护服务实例的列表可工作在一个集群中。在应用程序中，service - to - service调用是使用客户端来做。

以这个程序为例子，我使用[Spring Cloud Feign](https://github.com/spring-cloud-samples/feign-eureka), 客户端是依赖于一个RESTful的API 的微服务,它起源于[Netflix OSS](https://github.com/spring-cloud-samples/feign-eureka)项目. 
```
@FeignClient("movie")
public interface MovieClient {
    @RequestMapping(method = RequestMethod.GET, value = "/movies")
    PagedResources findAll();

    @RequestMapping(method = RequestMethod.GET, value = "/movies/{id}")
    Movie findById(@RequestParam("id") String id);

    @RequestMapping(method = RequestMethod.POST, value = "/movies",
      produces = MediaType.APPLICATION_JSON_VALUE)
    void createMovie(@RequestBody Movie movie);
}
```

在上面的例子，我创建了一个 模拟客户端，用RESTful 方法来暴露**movie service**。使用 **@FeignClient**注解，我首先指定我想为**movice micro service**来创建一个客户端的API。
接着，我指定一个我想要消费的微服务映射，我是通过在方法上声明URL的样式来做接口映射的（spring mvc类似），作为一个REST Ful 的路由映射。

创建一个模拟的客户端 是相当的简单，我们只是需要在我将要创建的客户端中，知道需要那个服务的ID。这个服务的URL将会在运行期间被自动配置，因为在集群中的每一个微服务在开启时它的ID都会被注册到**发现服务**中。

这同样适用于其他服务的microservice架构。我只是需要知道这个服务的Id,我就能和他做交互，这里的所有事情都会spring自动化了。

# API Gateway

API gateway 是另外一个重要的微服务，如果我们需要去创建一个微服务集群管理他们自己的领域实体类。绿色的六边形下面是数据驱动的服务，用来管理他们自己的领域模型实体类，以及他们自己的数据库。通过添加一个**API gateway service**， 我们可以创建一个API 路由的代理，并暴露给绿色的服务。
![Alt text](http://i.imgur.com/JVSGMfY.png "Optional title")

现在，我们假设 **recommendations service** 和 ** movie service ** 都暴露他们自己的REST API 给领域实体管理。这个API gateway 将会通过**discovery service**发现他们的服务和他们依赖注入其他服务的代理路由方法。
通过这个方式，** recommendation** 和 ** movice ** 服务，将会有一个完整的定义; 本地的路由映射是可以利用所有暴露 REST API 的微服务。API Gateway 将会重新定义转发路由请求服务实例，用自己的路由开始通过HTTP来发出请求。

# 例子项目
我把全部的例子项目都放到了一起，演示了一个从头到尾的 使用Spring cloud 构建本地云平台的实践架构。

概念：
- 使用Docker整合测试用例
- 混合持久化
- 微服务架构
- 服务发现
- API gateway

# Docker

每一个服务都是使用Docker来构建和发布的。从头到尾整合测试用例，能在一台开发机器中，使用Docker compose来做。

# 混合持久化（Polyglot Persistence）
这个示例项目的核心概念之一是在实践中如何走近通晓多种语言的持久性。Microservices项目中使用自己的数据库,同时结合数据从其他服务通过休息或一个消息总线。例如，你能有一个微服务，服务下面的数据库：
- Neo4j (graph)
- MongoDB (document)
- MySQL (relational)

# 微服务架构（Microservice architecture）
这个例子项目，演示了如何使用微服务构建一个新的应用程序，而不是monolith-first策略。
由于在项目中的每一个微服务都是父项目的一个模块，这样对开发者来说是非常友好的，可以在本地中运行和开发每一个微服务。添加一个新的微服务也是非常的容易，当**发现程序**可以自动发现新的在集群中运行的微服务。

# 服务发现（Service discovery）
这个项目包含2种类型的服务发现，其中一个是使用了Netflix Eureka, 以及另外一个是使用了Hashicorp 的 Consul。发现有多个服务提供了机会来使用一个(Consul)作为集群的DNS提供商，其他如（Eureka）作为一个API gateway 的代理。

# API gateway
每一个微服务，将会和Eureka 的检索整个集群API路由线，使用此策略中的每个microservice集群可以通过一个API网关负载均衡和暴露API gateway。每个服务将自动发现和API请求路由到服务拥有路线。这个代理技术是十分有帮助的在开发用户接口的时候，作为完整的API可用的平台是通过自己的主机作为代理。

# Docker 例子
这个Demo项目是使用Docker来构建一个内容镜像都是每个microservices Maven构建的一部分。我们可以轻松地安排整个microservice集群在自己的机器上使用Docker组件。

# 开始这个项目

你可以访问Github仓库，来获取这个例子的项目。
```
https://github.com/kbastani/spring-cloud-microservice-example
```
拷贝这个项目，和下载这个仓库到你的机器。在下载后，你将会需要，使用Maven 和Docker去编译和构建一个本地的镜像。

# 下载Docker

首先，下载一个Docker,如果你并没有安装。接着，按着这个介绍，[这里](https://docs.docker.com/compose/install/), 去获取Docker , 以及在你的开发机器上运行。

你将同时需要安装 [Docker Compose](https://docs.docker.com/compose/),这个安装指导，你可以在这里找到，[这里](https://docs.docker.com/compose/install/). 如果你已经安装了Mac OSX 和 boot2docker,确认你的boot2docker-vm的条件，是否最小为5G内存，下面这个命令将允许你这样设置：
```
$ boot2docker init --memory=5000
```

# 要求
运行这个Demo,需要一下这些条件：
- Maven3+
- Java 8+
- Docker 
- Docker Compose

# 构建这个项目
去构建这个项目，可以开启终端在项目的根目录下运行这个命令，
```
$ mvn clean install
```
在执行，这个命令，他会帮忙下载项目工程所需要的依赖包，以及编译每一个项目工程。每一个服务都会被构建，以及Maven的Docker 插件将会自动构建每一个镜像到本地的Docker 注册。在你运行  **mvn clean install**命令去构建的时候 Docker 必须先被运行，并且是可用的。
如果构建成功，你会看到这样的信息输出：
```
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] spring-cloud-microservice-example-parent .......... SUCCESS [  0.268 s]
[INFO] users-microservice ................................ SUCCESS [ 11.929 s]
[INFO] discovery-microservice ............................ SUCCESS [  5.640 s]
[INFO] api-gateway-microservice .......................... SUCCESS [  5.156 s]
[INFO] recommendation-microservice ....................... SUCCESS [  7.732 s]
[INFO] config-microservice ............................... SUCCESS [  4.711 s]
[INFO] hystrix-dashboard ................................. SUCCESS [  4.251 s]
[INFO] consul-microservice ............................... SUCCESS [  6.763 s]
[INFO] movie-microservice ................................ SUCCESS [  8.359 s]
[INFO] movies-ui ......................................... SUCCESS [ 15.833 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
```

# 开始使用Docker Compose 来组成集群

现在每一个镜像，已经被构建成功，我们可以使用Docker Compose 来 组成自旋向上的集群，我们将会包含一个预配置的yaml文件。
在项目的根目录，进入 **spring-cloud-mircroservice-example/docker**目录
现在，可以开启一个微服务集群，执行下面的命令：
```
$ docker-compose up
```

如果所有的事情都配置正确，每一个镜像都能更早的在我们自己的Docker VM 容器内，被运行构建，网络会自动服务发现. 你将会看见，一大串的log 输出，为每一个服务的开启的顺序。
这可能需要几分钟来编译整个程序，这个时间是由你的运行机器来决定的。

一旦启动顺序完成，你可以导航到 Eureka主机和看到哪些服务注册与发现服务。

复制和粘贴下面的命令行到你的终端，Docker能接近使用 **$DOCKER_HOST** 环境变量：
```
$ open $(echo \"$(echo $DOCKER_HOST)\"|
            \sed 's/tcp:\/\//http:\/\//g'|
            \sed 's/[0-9]\{4,\}/8761/g'|
            \sed 's/\"//g')
```

如果 Eureka 能正确开启，浏览器窗口将会开启一个本地的Eureka 服务的面板，就如下面所展示的那样：
![Eureka](http://i.imgur.com/buABI3h.png)

我们能看见，每一个服务实例的运行和运行状态。我们能接近这个数据驱动服务。这个演示程序的就是 **movie** 服务。
```
$ open $(echo \"$(echo $DOCKER_HOST)/movie\"|
            \sed 's/tcp:\/\//http:\/\//g'|
            \sed 's/[0-9]\{4,\}/10000/g'|
            \sed 's/\"//g')
```

这个命令，这个命令将导航到API网关的端点和代理**movie**服务的REST API端点。这些REST APIs 已经使用 **HATEOAS**来被配置了，它支持所有的服务的自动发现功能嵌入链接。
```
{
  "_links" : {
    "self" : {
      "href" : "http://192.168.59.103:10000/movie"
    },
    "resume" : {
      "href" : "http://192.168.59.103:10000/movie/resume"
    },
    "pause" : {
      "href" : "http://192.168.59.103:10000/movie/pause"
    },
    "restart" : {
      "href" : "http://192.168.59.103:10000/movie/restart"
    },
    "metrics" : {
      "href" : "http://192.168.59.103:10000/movie/metrics"
    },
    "env" : [ {
      "href" : "http://192.168.59.103:10000/movie/env"
    }, {
      "href" : "http://192.168.59.103:10000/movie/env"
    } ],
    "archaius" : {
      "href" : "http://192.168.59.103:10000/movie/archaius"
    },
    "beans" : {
      "href" : "http://192.168.59.103:10000/movie/beans"
    },
    "configprops" : {
      "href" : "http://192.168.59.103:10000/movie/configprops"
    },
    "trace" : {
      "href" : "http://192.168.59.103:10000/movie/trace"
    },
    "info" : {
      "href" : "http://192.168.59.103:10000/movie/info"
    },
    "health" : {
      "href" : "http://192.168.59.103:10000/movie/health"
    },
    "hystrix.stream" : {
      "href" : "http://192.168.59.103:10000/movie/hystrix.stream"
    },
    "routes" : {
      "href" : "http://192.168.59.103:10000/movie/routes"
    },
    "dump" : {
      "href" : "http://192.168.59.103:10000/movie/dump"
    },
    "refresh" : {
      "href" : "http://192.168.59.103:10000/movie/refresh"
    },
    "mappings" : {
      "href" : "http://192.168.59.103:10000/movie/mappings"
    },
    "autoconfig" : {
      "href" : "http://192.168.59.103:10000/movie/autoconfig"
    }
  }
}
```

# 结论
本系列的第一部分关于构建mircroservice架构与Spring-cloud 和 Docker。在本文章中，我们已经涉及到了以下的一些概念：
- 服务发现（Service Discovery）
- 扩展配置（Externalized Configuration）
- API Gateway
- 用Docker实现服务编排（Service Orchestration with Docker Compose）

在下一篇博文中,我们将复习如何构建应用程序前端与后端服务集成。我们也可以关注于这个例子[polyglot persistence](http://martinfowler.com/bliki/PolyglotPersistence.html)使用Mysql(关系型数据库) 和 Neo4j(图形数据库)。

# 特别感谢
我将会特别感谢[Josh Long](http://www.twitter.com/starbuxman) 和 spring 的 rest 团队给与我这个机会去学习spring 框架提供的第一手精美的东西。没有杰克的指导我将无法用语言表达的所有神奇的spring生态系统所能提供的东西。

这里有很多开源工具，想Spring Cloud。 这将是件不可能的事情，如果没有这些人的思想领导，如：[Adrian Cockcroft (Netflix OSS)](https://twitter.com/adrianco), [Martin Fowler (everything)](https://twitter.com/martinfowler)
[Sam Newman (O'Reilly's Building Microservices)](https://twitter.com/samnewman), [ Ian Robinson (consumer driven contracts)](https://twitter.com/iansrobinson)
[ Chris Richardson (Cloud Foundry) ](https://twitter.com/crichardson) 以及很多其他参与到开源工作的人们。

> 参考：
http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html






