---
title: 消息摘要与数字签名(补充基础知识)
categories:
- 源码阅读
- security源码导读系列
tags:
- jdk源码系列
- security源码导读系列
---


![vv](http://img2.tuicool.com/3mMjAf.jpg "title")
<!-- more -->

>导读：
在读java.security 源码时，发现有很多不懂的地方，需要补充一下基础知识。这章节主要说说Java安全的**消息摘要** 和 **数字签名** 的内容。

# 1、消息摘要
## 定义
他是有一个唯一对一个消息或文本的固定长度的值。它是由一个单向的Hash加密函数对消息进行作用而产生。如果消息在途中改变了，则接收者通过对收到消息的新产生的摘要与原摘要比较，就可知道消息是否被改变了。因此消息摘要保证了消息的完整性。消息摘要采用单向Hash 函数将需加密的明文"摘要"成一串密文，这一串密文亦称为数字指纹(Finger Print)。它有固定的长度，且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是"真身"的"指纹"了。
类是MD5加密，明文摘要成密文，过程不可逆，但密文是唯一的，只需要对比密文的一致性，就能知道原来的明文有没有因为远程传输而改变。
## 特点
消息摘要具有以下特点：
- 唯一性：数据只要有一点改变，那么再通过消息摘要算法得到的摘要也会发生变化。虽然理论上有可能会发生碰撞，但是概率极其低。
- 不可逆：消息摘要算法的密文无法被解密。
- 不需要密钥，可使用于分布式网络。
- 无论输入的明文有多长，计算出来的消息摘要的长度总是固定的。

原理
消息摘要，其实就是将需要摘要的数据作为参数，经过哈希函数(Hash)的计算，得到的散列值。
如下，给出常用的消息摘要工具类。
```
public class MessageDigestUtils {        
    /**
     * 默认字节缓冲区大小。
     */
    private static final int DEFAULT_BUFFER_SIZE = 1024 * 8;
    
    /**
     * 通过MD2算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持MD2算法。
     */
    public static byte[] getMD2Digest(byte[] input){
        //throw new UnsupportedOperationException();
        return getMessageDigest(input, MessageDigestAlgorithm.MD2);
    }
    
    /**
     * 通过MD2算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字节数组形式的消息摘要
     * @throws IOException  如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持MD2算法。
     */
    public static byte[] getMD2Digest(InputStream inputStream) throws IOException{
       // throw new UnsupportedOperationException();
       return getMessageDigest(inputStream, MessageDigestAlgorithm.MD2);
    }
    
    /**
     * 通过MD2算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持MD2算法。
     */
    public static String getMD2StringDigest(byte[] input){
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(input, MessageDigestAlgorithm.MD2);
    }
    
    /**
     * 通过MD2算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流。
     * @return 字符串形式的消息摘要。
     * @throws IOException 如果从数据流中读数据发生错误。
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持MD2算法。
     */
    public static String getMD2StringDigest(InputStream inputStream) throws IOException{
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(inputStream, MessageDigestAlgorithm.MD2);
    }
    
    /**
     * 通过MD5算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持MD5算法。
     */
    public static byte[] getMD5Digest(byte[] input){
       // throw new UnsupportedOperationException();
       return getMessageDigest(input, MessageDigestAlgorithm.MD5); 
    }
    
    
    /**
     * 通过MD5算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字节数组形式的消息摘要
     * @throws IOException 如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持MD5算法。
     */
    public static byte[] getMD5Digest(InputStream inputStream) throws IOException{
        // throw new UnsupportedOperationException();
        return getMessageDigest(inputStream, MessageDigestAlgorithm.MD5);
    }
    
    /**
     * 通过MD5算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持MD5算法。
     */
    public static String getMD5StringDigest(byte[] input){
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(input, MessageDigestAlgorithm.MD5);
    }
    
    /**
     * 通过MD5算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字符串形式的消息摘要
     * @throws IOException 如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持MD5算法。
     */
    public static String getMD5StringDigest(InputStream inputStream) throws IOException{
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(inputStream, MessageDigestAlgorithm.MD5);
    }
    
    /**
     * 通过SHA-1(简称SHA)算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-1算法。
     */
    public static byte[] getSHADigest(byte[] input){
       // throw new UnsupportedOperationException();
       return getMessageDigest(input, MessageDigestAlgorithm.SHA);
    }
    
    /**
     * 通过SHA-1(简称SHA)算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字节数组形式的消息摘要
     * @throws IOException 如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-1算法。
     */
    public static byte[] getSHADigest(InputStream inputStream) throws IOException{
        // throw new UnsupportedOperationException();
        return getMessageDigest(inputStream, MessageDigestAlgorithm.SHA);
    }
    
    /**
     * 通过SHA-1(简称SHA)算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-1算法。
     */
    public static String getSHAStringDigest(byte[] input){
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(input, MessageDigestAlgorithm.SHA);
    }
    
    /**
     * 通过SHA-1(简称SHA)算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字符串形式的消息摘要
     * @throws IOException  如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-1算法。
     */
    public static String getSHAStringDigest(InputStream inputStream) 
            throws IOException{
       // throw new UnsupportedOperationException();
       return getStringMessageDigest(inputStream, MessageDigestAlgorithm.SHA);
    }
    
    /**
     * 通过SHA-256算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据流
     * @return  字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-256算法。
     */
    public static byte[] getSHA256Digest(byte[] input){
       // throw new UnsupportedOperationException();
       return getMessageDigest(input, MessageDigestAlgorithm.SHA256);
    }
    
    /**
     * 通过SHA-256算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字节数组形式的消息摘要
     * @throws IOException 如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-256算法。
     */
    public static byte[] getSHA256Digest(InputStream inputStream) 
            throws IOException{
        // throw new UnsupportedOperationException();
        return getMessageDigest(inputStream, MessageDigestAlgorithm.SHA256);
    }
    
    /**
     * 通过SHA-256算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return  字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-256算法。
     */
    public static String getSHA256StringDigest(byte[] input){
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(input, MessageDigestAlgorithm.SHA256);
    }
    
    /**
     * 通过SHA-256算法进行消息摘要
     * 
     * @param inputStream
     * @return 
     *      字符串形式的消息摘要
     * @throws IOException 如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-256算法。
     */
    public static String getSHA256StringDigest(InputStream inputStream) 
            throws IOException{
        // throw new UnsupportedOperationException();
        return getStringMessageDigest(inputStream, MessageDigestAlgorithm.SHA256);
    }
    
    /**
     * 通过SHA-384算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-384算法。
     */
    public static byte[] getSHA384Digest(byte[] input){
       // throw new UnsupportedOperationException();
       return getMessageDigest(input, MessageDigestAlgorithm.SHA384);
    }
    
    /**
     * 通过SHA-384算法进行消息摘要。
     * 
     * @param inputStream inputStream 要进行消息摘要的数据流。
     * @return 字节数组形式的消息摘要。
     * @throws IOException 如果从数据流中读数据发生错误。
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-384算法。
     */
    public static byte[] getSHA384Digest(InputStream inputStream) throws IOException{
       // throw new UnsupportedOperationException();
       		return getMessageDigest(inputStream, MessageDigestAlgorithm.SHA384);
    }
    
    /**
     * 通过SHA-384算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-384算法。
     */
    public static String getSHA384StringDigest(byte[] input){
       //throw new UnsupportedOperationException();
       return getStringMessageDigest(input, MessageDigestAlgorithm.SHA384);
    }
    
    /**
     * 通过SHA-384算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字符串形式的消息摘要
     * @throws IOException  如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-384算法。
     */
    public static String getSHA384StringDigest(InputStream inputStream) 
            throws IOException{
        //  throw new UnsupportedOperationException();  
        return getStringMessageDigest(inputStream, MessageDigestAlgorithm.SHA384);
    }
    
    /**
     * 通过SHA-512算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return  字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-512算法。
     */
    public static byte[] getSHA512Digest(byte[] input){
        // throw new UnsupportedOperationException();
        return getMessageDigest(input, MessageDigestAlgorithm.SHA512);
    }
    
    /**
     * 通过SHA-512算法进行消息摘要。
     * 
     * @param inputStream 要进行消息摘要的数据流。
     * @return 字节数组形式的消息摘要。
     * @throws IOException 如果从数据流中读数据发生错误。
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-512算法。
     */
    public static byte[] getSHA512Digest(InputStream inputStream) 
            throws IOException{ 
        // throw new UnsupportedOperationException();
        return getMessageDigest(inputStream, MessageDigestAlgorithm.SHA512);
    }
    
    /**
     * 通过SHA-512算法进行消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @return 字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null或者JDK不支持SHA-512算法。
     */
    public static String getSHA512StringDigest(byte [] input) {
        //throw new UnsupportedOperationException();
        return getStringMessageDigest(input, MessageDigestAlgorithm.SHA512);
    }
    
    /**
     * 通过SHA-512算法进行消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流
     * @return 字符串形式的消息摘要
     * @throws IOException 如果从数据流中读数据发生错误
     * @throws IllegalArgumentException 如果参数inputStream为null或者JDK不支持SHA-512算法。
     */
    public static String getSHA512StringDigest(InputStream inputStream) 
            throws IOException {        
       return getStringMessageDigest(inputStream, MessageDigestAlgorithm.SHA512);
    }
    
    /**
     * 获取消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @param alogrithm 消息摘要算法 @see {@link MessageDigestAlgorithm}
     * @return 字节数组形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null，或者algorithm为空或不被JDK支持。
     */
    private static byte[] getMessageDigest(byte[] input, MessageDigestAlgorithm algorithm) {
        // throw new UnsupportedOperationException();
        Assert.notNull(input, "要进行消息摘要的数据不能为空!");
        Assert.notNull(algorithm, "消息摘要算法不能为空!");
        try {
                MessageDigest messageDigest = MessageDigest.getInstance(algorithm.getName());
                return messageDigest.digest(input);
        } catch (NoSuchAlgorithmException e) {
                throw new IllegalArgumentException(e);
        }        
    }
    
    /**
     * 获取消息摘要
     * 
     * @param input 要进行消息摘要的数据
     * @param alogrithm 消息摘要算法 @see {@link  MessageDigestAlogrithm}
     * @return 字符串形式的消息摘要
     * @throws IllegalArgumentException 如果参数input为null，或者algorithm为空或不被JDK支持。
     */
    private static String getStringMessageDigest(byte[] input, MessageDigestAlgorithm algorithm) {
        // throw new UnsupportedOperationException();
        byte[] digest = getMessageDigest(input, algorithm);
        return HexUtils.toHexString(digest);        
    }
    
    /**
     * 获取消息摘要。
     * @param inputStream 要进行消息摘要的数据流。
     * @param alogrithm 消息摘要算法 @see {@link MessageDigestAlogrithm }
     * @return 字节数组形式的消息摘要。
     * @throws IOException 如果从数据流中读取数据发生错误。
     * @throws IllegalArgumentException 如果参数inputStream为null，或者algorithm为空或不被JDK支持。
     */
    private static byte[] getMessageDigest (InputStream inputStream, MessageDigestAlgorithm algorithm) 
            throws IOException {
        //throw new UnsupportedOperationException();
        Assert.notNull(inputStream, "要进行消息摘要的数据流不能为空!");
        Assert.notNull(algorithm, "消息摘要算法不能为空!");
        try {
            MessageDigest messageDigest = MessageDigest.getInstance(algorithm.getName());
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            int len = -1;
            while ((len = inputStream.read(buffer)) > -1) {
                messageDigest.update(buffer, 0, len);
            }
            return messageDigest.digest();
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException(e);
        }        
    }
    
    /**
     * 获取消息摘要
     * 
     * @param inputStream 要进行消息摘要的数据流。
     * @param alogrithm 消息摘要算法 @see {@link MessageDigestAlogrithm}。
     * @return 字符串形式的消息摘要。
     * @throws IOException 如果从数据流中读数据发生错误。
     * @throws IllegalArgumentException 如果参数inputStream为null，或者algorithm为空或不被JDK支持。
     */
    private static String getStringMessageDigest(InputStream inputStream, MessageDigestAlgorithm algorithm) 
            throws IOException {        
        byte[] digest = getMessageDigest(inputStream, algorithm);
        return HexUtils.toHexString(digest);
    }
    
    private MessageDigestUtils() {} 
    
    /**
     * 消息摘要算法
     * 
     * 这里只是列举JDK6以上（包含6）支持的算法
     */
    public static enum  MessageDigestAlgorithm {
        
        MD2("MD2",128),
        MD5("MD5",128),
        SHA("SHA-1",160),
        SHA256("SHA-256",256),
        SHA384("SHA-384",384),
        SHA512("SHA-512",512);
        
        /**
         * 算法名称
         */
        private String name;
        
        /**
         * 摘要长度（单位：比特）
         */
        private int digestLength;

        private  MessageDigestAlgorithm(String name,int digestLength) {
            this.name = name;
            this.digestLength = digestLength;
        }

        public String getName() {
            return name;
        }

        public int getDigestLength() {
            return digestLength;
        }                
    }
    
}

```

## 常用算法
MD2("MD2",128),
MD5("MD5",128),
SHA("SHA-1",160),
SHA256("SHA-256",256),
SHA384("SHA-384",384),
SHA512("SHA-512",512);

消息摘要算法包括MD(Message Digest，消息摘要算法)、SHA(Secure Hash Algorithm，安全散列算法)、MAC(Message AuthenticationCode，消息认证码算法)共3大系列，常用于验证数据的完整性，是数字签名算法的核心算法。
MD5和SHA1分别是MD、SHA算法系列中最有代表性的算法。
如今，MD5已被发现有许多漏洞，从而不再安全。SHA算法比MD算法的摘要长度更长，也更加安全。

# 2、数字签名
数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。

## 算法简述
**数字签名算法**可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是**非对称加密算法和消息摘要算法的结合体**。

## 特点

数字签名算法要求能够验证数据完整性、认证数据来源，并起到抗否认的作用。

原理
数字签名算法包含签名和验证两项操作，遵循私钥签名，公钥验证的方式。
签名时要使用私钥和待签名数据，验证时则需要公钥、签名值和待签名数据，其核心算法主要是消息摘要算法。

常用算法：
RSA、DSA、ECDSA

实现：RSA
```
public class RSASignatureUtils {
    
    /**
     * RSA算法名称。
     */
    private static final String ALGORITHM = "RSA";
    
    /**
     * 对数据进行签名。
     * 
     * @param data 待签名的数据。
     * @param privateKey 私钥。
     * @param signatureAlgorithm 数字签名算法。 参见{@link SignatureAlgorithm}
     * @return  
     *      数字签名。
     * @throws IllegalArgumentException 如果参数不合法。
     * @throws IllegalStateException 如果在签名过程中发生错误。
     */
    public static byte[] sign(byte[] data, byte[] privateKey, SignatureAlgorithm signatureAlgorithm){
        //throw new UnsupportedOperationException();
        Assert.notNull(data, "要签名的数据不能为null!");
        Assert.notNull(signatureAlgorithm, "数字签名算法不能为null!");
        try {
            PrivateKey key = EncryptionBase.toPrivateKey(privateKey, ALGORITHM);
            Signature signature = Signature.getInstance(signatureAlgorithm.getName());
            signature.initSign(key);
            signature.update(data);
            return signature.sign();
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException(e);
        } catch (InvalidKeyException e) {
            throw new IllegalArgumentException(e);
        } catch (SignatureException e) {
            throw new IllegalStateException(e);
        }        
    }
    
    /**
     * 对数据的数字签名进行验证。
     * 
     * @param data 待验证数据。
     * @param publicKey 公钥。
     * @param sign data的数据签名。
     * @param signatureAlgorithm 数字签名算法。参见{@link SignatureAlgorithm}
     * @return 
     *      签名是否有效。
     * @throws IllegalArgumentException 如果参数不合法。
     * @throws IllegalStateException 如果在验证过程中发生错误。
     * 
     */
    public static boolean verify(byte[] data, byte[] publicKey, byte[] sign, SignatureAlgorithm signatureAlgorithm){
        // throw new UnsupportedOperationException();
        Assert.notNull(data, "要验证的数据不能为null!");
        Assert.notNull(sign, "数字签名不能为null!");
        Assert.notNull(signatureAlgorithm, "数字签名算法不能为null!");
        try {
            PublicKey key = EncryptionBase.toPublicKey(publicKey, ALGORITHM);
            Signature signature = Signature.getInstance(signatureAlgorithm.getName());
            signature.initVerify(key);
            signature.update(data);
            return signature.verify(sign);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException(e);
        } catch (InvalidKeyException e) {
            throw new IllegalArgumentException(e);
        } catch (SignatureException e) {
            throw new IllegalStateException(e);
        }       
    }
    
    /**
     * RSA数字签名算法。 
     * 这里只列举JDK6支持的算法。
     */    
    public static enum SignatureAlgorithm{
        MD2WithRSA("MD2WithRSA"),
        MD5WithRSA("MD5WithRSA"),
        SHA1WithRSA("SHA1WithRSA"),
        SHA256WithRSA("SHA256WithRSA"),
        SHA384WithRSA("SHA384WithRSA"),
        SHA512WithRSA("SHA512WithRSA");

        /**
         * 算法名称。
         */
        private String name;

        private SignatureAlgorithm(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }        
    }
    
    private RSASignatureUtils(){}
}
```

DSA：
```
public class DSASignatureUtils {
    
    /**
     * DSA算法名称。
     */
    private static final String ALGORITHM = "DSA";
    
    /**
     * JDK6支持的DSA算法默认密钥长度。
     */
    private static final int KEYSIZE = 1024;
    
    /**
     * 生成一个密钥对Bean(包括公钥和私钥)。
     * 
     * @param keySize 密钥长度(必须大于等于512且小于等于1024，同时是64的倍数。)
     * @return 密钥对。
     * @throws IllegalArgumentException 如果密钥长度不合法。
     * @throws IllegalStateException 如果系统不支持DSA算法。
     */
    public static KeyPairBean generateKeyPair(int keySize){
       //throw new UnsupportedOperationException();
        Assert.isTrue(keySize >= 512 && keySize <= 1024 && keySize % 64 == 0,
                "密钥长度必须大于等512且小于等于1024，同时是64的倍数!");
        return EncryptionBase.generateKeyPair(ALGORITHM, keySize);       
    }
    
    /**
     * 生成一个密钥对Bean(包括公钥和私钥)。
     * <p>使用默认密钥长度1024。
     * 
     * @return  密钥对。
     * @throws IllegalArgumentException 如果密钥长度不合法。
     * @throws IllegalStateException 如果系统不支持DSA算法。
     */
    public static KeyPairBean generateKeyPair(){
        // throw new UnsupportedOperationException();
        return generateKeyPair(KEYSIZE);
    }
    
    /**
     * 对数据进行签名。
     * 
     * @param data 待签名的数据。
     * @param privateKey 私钥。
     * @param signatureAlgorithm 数字签名算法。 参见{@link SignatureAlgorithm}
     * @return 
     *      数字签名。
     * @throws IllegalArgumentException 如果参数不合法。
     * @throws IllegalStateException 如果在签名过程中发生错误。
     */
    public static byte[] sign(byte[] data, byte[] privateKey, SignatureAlgorithm signatureAlgorithm){
        // throw new UnsupportedOperationException();
        Assert.notNull(data, "要签名的数据不能为null!");
        Assert.notNull(signatureAlgorithm, "数字签名算法不能为null!");
        try {
                PrivateKey key = EncryptionBase.toPrivateKey(privateKey, ALGORITHM);
                Signature signature = Signature.getInstance(signatureAlgorithm.getName());
                signature.initSign(key);
                signature.update(data);
                return signature.sign();
        } catch (NoSuchAlgorithmException e) {
                throw new IllegalArgumentException(e);
        } catch (InvalidKeyException e) {
                throw new IllegalArgumentException(e);
        } catch (SignatureException e) {
                throw new IllegalStateException(e);
        }        
    }
    
    /**
     * 对数据的数字签名进行验证。
     * 
     * @param data 待验证数据。
     * @param publicKey 公钥。
     * @param sign data的数据签名。
     * @param signatureAlgorithm 数字签名算法。参见{@link SignatureAlgorithm}
     * @return  
     *      签名是否有效。
     * @throws IllegalArgumentException 如果参数不合法。
     * @throws IllegalStateException 如果在验证过程中发生错误。
     */
    public static boolean verify(byte[] data, byte[] publicKey, byte[] sign, SignatureAlgorithm signatureAlgorithm) throws SignatureException{
        // throw new UnsupportedOperationException();
        Assert.notNull(data, "要验证的数据不能为null!");
        Assert.notNull(sign, "数字签名不能为null!");
        Assert.notNull(signatureAlgorithm, "数字签名算法不能为null!");
        try {
                PublicKey key = EncryptionBase.toPublicKey(publicKey, ALGORITHM);
                Signature signature = Signature.getInstance(signatureAlgorithm.getName());
                signature.initVerify(key);
                signature.update(data);
                return signature.verify(sign);
        } catch (NoSuchAlgorithmException e) {
                throw new IllegalArgumentException(e);
        } catch (InvalidKeyException e) {
                throw new IllegalArgumentException(e);
        } catch (SignatureException e) {
                throw new IllegalStateException(e);
        }        
    }
    
    /**
     * DSA数字签名算法。
     * 这里只列举JDK6支持的算法。
     */
    public static enum SignatureAlgorithm{
        SHA1WithDSA("SHA1WithDSA");
        /**
         * 算法名称。
         */
        private String name;

        private SignatureAlgorithm(String name) {
                this.name = name;
        }

        public String getName() {
                return name;
        }        
    }
    
    private DSASignatureUtils(){}
}
```

>参考文章：
http://www.cnblogs.com/jingmoxukong/p/5700906.html
http://www.cnblogs.com/jingmoxukong/p/5688306.html
《Core Java Volume2》
《Java加密与解密技术》
