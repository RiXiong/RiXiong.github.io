---
title: java.security源码解读系列-PKI.**Key**
categories:
- 源码阅读
- security源码导读系列
tags:
- jdk源码系列
- security源码导读系列
---


>导读：
- 这是个人阅读jdk 源码的一个系列，java.security时写的文章，希望写该篇文章，能加深自己对于java语言的理解。
- 本文相关的JDK版本是JDK7,jdk8

<!-- more -->

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="http://music.163.com/outchain/player?type=0&id=434934139&auto=1&height=430"></iframe>

在翻看，jce 的源码中，笔者发现，jce中的源码都基本引用到了java.security 下的类；
通过上篇的导读，我们基本可以了解java.security 的基本架构的主要组成：
- PKI (public key infrastructure)
- 认证(authentication)
- 安全通信(secure conmmunication)
- 访问控制(access control)

# PKI
PKI ------ 公钥基础构件
**PKI**是一个术语，主要用于描述一类基于公钥的安全信息交互框架。它允许identity，比如人或者组织，绑定在数字证书上，并且提供一种验证证书的方法。PKI包括了密钥、证书、公钥加密和可信的证书颁发机构(CAs，用于生成和签署证书)。
Java平台提供API和provider支持X.509、CRLs、PKIX证书路径的构建和验证。
java Security API提供了可互操作的算法和安全服务的实现。服务以provider的形式实现，可以以插件的形式植入应用程序中。程序员可以透明地使用这些服务，如此使得程序员可以集中精力在如何把安全组件集成到自己的应用程序中，而不是去实现这些安全功能。
既然Provider 是如此总要的，好奇的我总是要去看看的：
看到该类的作者是：本杰明雷诺（Benjamin Renaud） 和 安德烈亚斯斯特本兹（Andreas Sterbenz）
**PKI**相关的类可以在**java.security**和**java.security.cert**包下获取。

# PKI的组成
- **密匙 key**
- **证书 certificate**
- **公钥加密 Public key encryption（PKE）**
- **可信的证书颁发机构 CAS**

# KeyStore
下面我们来说说密钥：
密钥在jdk 中，她主要是是通过 key store 来实现，相关涉及的类都是 XXkeyXX 这类的形式。我们先看看java.security.KeyStore类，在该类的类头部，注释已经说明她是一个用来存储密钥和证书的类或叫数据解构更加合适。
在KeyStore中包含了好几个内部类，蛮有意思的，包括Builder内部类数据解构的构建者，
**CallbackHandlerProtection**,
**PasswordParameter**,
**PrivateKeyEntry**, 私钥，一个存储加密过的私钥，用来存储保护的信息，防止非法访问。
**SecretKeyEntry**, 密钥
**SimpleLoadStoreParameter**, 
**TrustedCeritificateEntry** 可信任证书，他包含一个单一的公钥，可以供给别人使用，我们称为可信任证书

要学习如何看源码，看源码的注释是必不可少的，幸运的是JKD的源码注释是那么的清晰。哈哈，感谢前人的努力。
**KeyStore**是用来存储加密密钥和加密证书的存储解构，类的表头注释来了个开门见山。
**KeyStore**可以支持不同的实体类型的存储结构，每一个类型都实现了内部的一个KeyStore.Entry 接口。
它支持一下的几种存储解构类型：

- **KeyStore.PrivateKeyEntry**
>这个存储解构持有 加密的 **PrivateKey**(私钥)，用来存储一个被保护的格式数据，防止被接近访问。同时他也会实现一个对公钥开放的证书链来供外部访问。
私钥和证书主要是个一个已经被授权的应用来访问私钥和证书链的。

```
    public static final class PrivateKeyEntry implements Entry {

        private final PrivateKey privKey; 
		
        private final Certificate[] chain;
        private final Set<Attribute> attributes;

        public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain) {
            this(privateKey, chain, Collections.<Attribute>emptySet());
        }
        public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain,
           Set<Attribute> attributes) {

            if (privateKey == null || chain == null || attributes == null) {
                throw new NullPointerException("invalid null input");
            }
            if (chain.length == 0) {
                throw new IllegalArgumentException
                                ("invalid zero-length input chain");
            }

            Certificate[] clonedChain = chain.clone();
            String certType = clonedChain[0].getType();
            for (int i = 1; i < clonedChain.length; i++) {
                if (!certType.equals(clonedChain[i].getType())) {
                    throw new IllegalArgumentException
                                ("chain does not contain certificates " +
                                "of the same type");
                }
            }
            if (!privateKey.getAlgorithm().equals
                        (clonedChain[0].getPublicKey().getAlgorithm())) {
                throw new IllegalArgumentException
                                ("private key algorithm does not match " +
                                "algorithm of public key in end entity " +
                                "certificate (at index 0)");
            }
            this.privKey = privateKey;

            if (clonedChain[0] instanceof X509Certificate &&
                !(clonedChain instanceof X509Certificate[])) {

                this.chain = new X509Certificate[clonedChain.length];
                System.arraycopy(clonedChain, 0,
                                this.chain, 0, clonedChain.length);
            } else {
                this.chain = clonedChain;
            }

            this.attributes =
                Collections.unmodifiableSet(new HashSet<>(attributes));
        }
        public PrivateKey getPrivateKey() {
            return privKey;
        }
        public Certificate[] getCertificateChain() {
            return chain.clone();
        }
        public Certificate getCertificate() {
            return chain[0];
        }
        @Override
        public Set<Attribute> getAttributes() {
            return attributes;
        }
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Private key entry and certificate chain with "
                + chain.length + " elements:\r\n");
            for (Certificate cert : chain) {
                sb.append(cert);
                sb.append("\r\n");
            }
            return sb.toString();
        }

    }
```

- **KeyStore.SecretKeyEntry**
> 这个存储解构是存储加密过的**SecretKey**，来防止没授权访问。

```
    public static final class SecretKeyEntry implements Entry {

        private final SecretKey sKey;
        private final Set<Attribute> attributes;
        public SecretKeyEntry(SecretKey secretKey) {
            if (secretKey == null) {
                throw new NullPointerException("invalid null input");
            }
            this.sKey = secretKey;
            this.attributes = Collections.<Attribute>emptySet();
        }
        public SecretKeyEntry(SecretKey secretKey, Set<Attribute> attributes) {

            if (secretKey == null || attributes == null) {
                throw new NullPointerException("invalid null input");
            }
            this.sKey = secretKey;
            this.attributes =
                Collections.unmodifiableSet(new HashSet<>(attributes));
        }
        public SecretKey getSecretKey() {
            return sKey;
        }
        @Override
        public Set<Attribute> getAttributes() {
            return attributes;
        }
        public String toString() {
            return "Secret key entry with algorithm " + sKey.getAlgorithm();
        }
    }
```

- **KeyStore.TrustedCertificateEntry**
> 这个存储实体包含一个单一的公钥，证书是属于另外的一部分，被叫做可信任证书。因为**StoreKey**的拥有者，对这些证书是已经有明确的身份确认的。通过这类证书实体，我们可以用来实现授权第三方的用户。

```
    public static final class TrustedCertificateEntry implements Entry {

        private final Certificate cert;
        private final Set<Attribute> attributes;
        public TrustedCertificateEntry(Certificate trustedCert) {
            if (trustedCert == null) {
                throw new NullPointerException("invalid null input");
            }
            this.cert = trustedCert;
            this.attributes = Collections.<Attribute>emptySet();
        }
        public TrustedCertificateEntry(Certificate trustedCert,
           Set<Attribute> attributes) {
            if (trustedCert == null || attributes == null) {
                throw new NullPointerException("invalid null input");
            }
            this.cert = trustedCert;
            this.attributes =
                Collections.unmodifiableSet(new HashSet<>(attributes));
        }
        public Certificate getTrustedCertificate() {
            return cert;
        }
        @Override
        public Set<Attribute> getAttributes() {
            return attributes;
        }

        /**
         * Returns a string representation of this TrustedCertificateEntry.
         * @return a string representation of this TrustedCertificateEntry.
         */
        public String toString() {
            return "Trusted certificate entry:\r\n" + cert.toString();
        }
    }
```

# KeyStore使用：
上述的实体类中，每个Entry都快可以有自己的实体别名。
使用KeyStore的一些常用方法：

- 依赖于默认类型
```
KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
```

- 提供一个特殊的KeyStore类型
```
 KeyStore ks = KeyStore.getInstance("JKS");
```

- 通过输入流来载入KeyStore
```
KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());

/** get user password and file input stream*/
char[] password = getPassword();

try (FileInputStream fis = new FileInputStream("keyStoreName")) {
 ks.load(fis, password);
}
```

- 构造一个空的KeyStore
```
    KeyStore.ProtectionParameter protParam =
        new KeyStore.PasswordProtection(password);

    /** get my private key**/
    KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)
        ks.getEntry("privateKeyAlias", protParam);
    PrivateKey myPrivateKey = pkEntry.getPrivateKey();

    /** save my secret key**/
    javax.crypto.SecretKey mySecretKey;
    KeyStore.SecretKeyEntry skEntry =
        new KeyStore.SecretKeyEntry(mySecretKey);
    ks.setEntry("secretKeyAlias", skEntry, protParam);

    /** store away the keystore**/
    try (FileOutputStream fos = new FileOutputStream("newKeyStoreName")) {
        ks.store(fos, password);
    }
```

下面，我们在来看看其他的**Key**
Key 接口：
```
/**@author Benjamin Renaud**/
public interface Key extends java.io.Serializable {
    static final long serialVersionUID = 6603384152749567654L;
	public String getAlgorithm(); // 获取加密算法名，如DSA,就是DSA算法的密钥。
	public String getFormat();// 返回这个key的主要解码格式的名称,
	public byte[] getEncoded();//返回Key的解码
}
```
在来看看KeyException 类：
```
/**@author Benjamin Renaud**/
public class KeyException extends GeneralSecurityException {
    public KeyException() {
        super();
    }
	public KeyException(String msg) {
        super(msg);
    }
	public KeyException(String message, Throwable cause) {
        super(message, cause);
    }
	public KeyException(Throwable cause) {
        super(cause);
    }
}
```
这是比较常见的异常类，在Key 的算法返回值为null 时会抛出该异常。他的父级异常 GeneralSecurityException 和Exception 类跟他的构造方法类是。

KeyFactory 类：
从名字中，就能知道这是一个工厂方法的类。这个类是在1.2版本中加入的，作者部署本杰明雷，而是Jan Luehe
这个类主要是用来做 转换那些并不透明的加密密钥类型的Key，为一些按照特殊规范的透明Key,这是一个双向的过程。
Service Provider Interface(SPI)
```
public class KeyFactory{
    private final String algorithm;
	private Provider provider;
	private volatile KeyFactorySpi spi;
	private final Object lock = new Object();
	private Iterator<Service> serviceIterator;
	
	protected KeyFactory(KeyFactorySpi keyFacSpi, Provider provider,
                         String algorithm){......}
	private KeyFactory(String algorithm) throws NoSuchAlgorithmException {......}
	
	public static KeyFactory getInstance(String algorithm){......}
    public static KeyFactory getInstance(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {......}
    public static KeyFactory getInstance(String algorithm, Provider provider)
            throws NoSuchAlgorithmException {......}
			
	public final Provider getProvider() {
        synchronized (lock) {
            serviceIterator = null;
            return provider;
        }
    } 
	public final String getAlgorithm() {
        return this.algorithm;
    }
	private KeyFactorySpi nextSpi(KeyFactorySpi oldSpi) {/** keyFactory 分派key **/
        synchronized (lock) {
		    ......
		}
	}
	public final PublicKey generatePublic(KeySpec keySpec)
            throws InvalidKeySpecException {.......}
	public final PrivateKey generatePrivate(KeySpec keySpec)
            throws InvalidKeySpecException {......}
	public final <T extends KeySpec> T getKeySpec(Key key, Class<T> keySpec)
            throws InvalidKeySpecException {......}		
	public final Key translateKey(Key key) throws InvalidKeyException {......}		
}
```

KeyFactorySpi 抽象类：
继承这个类中的所有抽象方法必须实现由 provider 供应关键工厂特定的实现算法。
KeyPair 类：
同时持有公钥和私钥。

此外，在*java.security.spec* 下面，也提供了很多的**XXKeyXX**的实现，这是由于历史的原因没有放到**java.security.* **下面。
如：
**java.security.spec.KeySpec;** 接口， All key specifications must implement this interface. 源码的注释中已经说明了，所有的规格化的Key都必须要实现这个接口。
**java.security.spec.PKCS8EncodedKeySpec;** 这是一套解码规范。PKCS#8 标准
**java.security.spec.X509EncodedKeySpec;**  这是一套解码规范，X.509 标准

他们都同一实现了keySpe 接口。

在java.security.interface 中定义了各种special key 的接口实现。

# 证书
在 java.security.cert 中有各种证书的实现, 都是XXCertXX 
其中，的 CertStore 和 KeyStore 的结构类似。
证书是 ， 密钥外的另外一种加密方式。



>参考文章：
http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html
http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）
http://m635674608.iteye.com/blog/1844777（强推荐）
http://joshuasabrina.iteye.com/blog/1798245（强推荐）
http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）
http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）
http://www.cnblogs.com/NullPointException/p/5054082.html
http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html