---
title: java.security源码解读系列-消息摘要与数字签名
categories:
- 源码阅读
- security源码导读系列
tags:
- jdk源码系列
- security源码导读系列
---

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="http://music.163.com/outchain/player?type=0&id=434934139&auto=1&height=430"></iframe>
>导读：
- 这是个人阅读jdk 源码的一个系列，java.security时写的文章，希望写该篇文章，能加深自己对于java语言的理解。
- 本文相关的JDK版本是JDK7,jdk8
- 作者：灯塔
- 原文： 

签名类是用于提供应用程序的功能的数字签名算法。数字签名用于身份验证和完整性保证数字数据。签名算法并不只是局限为DSA sha-1 算法，可以是MD2+RSA DSA+sha-1 这种特殊的结合，还可以加盐等等，签名对象可以用于生成和验证数字签名。
Signature对象可以用于生成和验证数字签名。

<!-- more -->

我们先来看看Signature 类：
```
/**@author Benjamin Renaud**/
public abstract class Signature extends SignatureSpi {
  ....... 
}
```
通过类的继承SignatureSpi 我们知道，Signature 是属于SPI（Service Provider Interface）体系下的，也就是说，他类实现中必然提供了一个 getProvider() 方法，支持签名算法的别名实现。

在看源码的时候，发现好多这种代码
```
private static final Debug debug =
					Debug.getInstance("jca", "Signature");

private static final Debug pdebug =
					Debug.getInstance("provider", "Provider");
private static final boolean skipDebug =
	Debug.isOn("engine=") && !Debug.isOn("signature");
```
很多Debug.XX() 的实现。这好像是 Java Platform Debugger Architecture  下的东西 ，具体可以看这里：http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html
是securiy 下面的一个工具类：


Signature 对象是一个抽象类，意味这他必然要被继承。
我们再次具体的看看他的源码实现
``` 
/**@author Benjamin Renaud**/
public abstract class Signature extends SignatureSpi {
   private String algorithm;
   /**The provider 包内可见**/
   Provider provider;
   
   private final static Map<String,Boolean> signatureInfo;

   static {
        signatureInfo = new ConcurrentHashMap<String,Boolean>();
        Boolean TRUE = Boolean.TRUE;
        // pre-initialize with values for our SignatureSpi implementations
        signatureInfo.put("sun.security.provider.DSA$RawDSA", TRUE);
        signatureInfo.put("sun.security.provider.DSA$SHA1withDSA", TRUE);
        signatureInfo.put("sun.security.rsa.RSASignature$MD2withRSA", TRUE);
        signatureInfo.put("sun.security.rsa.RSASignature$MD5withRSA", TRUE);
        signatureInfo.put("sun.security.rsa.RSASignature$SHA1withRSA", TRUE);
        signatureInfo.put("sun.security.rsa.RSASignature$SHA256withRSA", TRUE);
        signatureInfo.put("sun.security.rsa.RSASignature$SHA384withRSA", TRUE);
        signatureInfo.put("sun.security.rsa.RSASignature$SHA512withRSA", TRUE);
        signatureInfo.put("com.sun.net.ssl.internal.ssl.RSASignature", TRUE);
        signatureInfo.put("sun.security.pkcs11.P11Signature", TRUE);
   }
   
   public final void initSign(PrivateKey privateKey)
            throws InvalidKeyException {
        engineInitSign(privateKey);
        state = SIGN;

        if (!skipDebug && pdebug != null) {
            pdebug.println("Signature." + algorithm +
                " signing algorithm from: " + this.provider.getName());
        }
    }
	
	//这里有一个加密适配器，将来会废除
    @SuppressWarnings("deprecation")
    private static class CipherAdapter extends SignatureSpi {

        private final Cipher cipher;

        private ByteArrayOutputStream data;
	｝	
}	
```


>参考：
http://www.cnblogs.com/jingmoxukong/p/5700906.html
http://www.cnblogs.com/jingmoxukong/p/5688306.html