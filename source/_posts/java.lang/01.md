---
title: lang包之 System
categories:
- 源码阅读
- lang包
tags:
- jdk源码系列
- java
---

>导读：
- 作者: 灯塔
- 源码：jdk1.8

在我们初学习编程之处，就我来说，我一开始接触编程的语言是c语言，我相信大多数科班出身的都跟我一样，首先学习的是print("Hello World").
在我学习java时，我也是如此，毕竟学习过一门语言，再学习其他就很好的掌握方法了。
在java 学习中， 我们是
```
System.out.println("Hello world!“);
```
当年学习的时候，会个Hello world! 对我来说已经是件兴奋不已的事情，却并没有好好的看看**System**中的源码

**System**的类，包含了几个有用的属性，和方法，他们不能被实例化，下面这些方法都是**System**类所提供的。
如：标准的输入流，标准的输出流，以及错误的输出流，和一些扩展定义的属性和环境变量方法。都是加载文件和库的一种手段，一个实用程序的方法和快速复制数组的一部分。

先过目一下，这个牛叉的代码：
```
public final class System {
   /** openjdk 能找到这个cpp 文件**/
   private static native void registerNatives();
   static {
      registerNatives();
   }   
   /** 防止被实例化**/
   private System() {}
   public final static InputStream in = null;
   public final static PrintStream out = null;
   public final static PrintStream err = null;
   /** 允许实现安全策略 **/
   private static volatile SecurityManager security = null;
   ......
   ......
   public static Console console() {
         if (cons == null) {
             synchronized (System.class) {
                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();
             }
         }
         return cons;
   }
   ......
   ......
   public static
   void setSecurityManager(final SecurityManager s) {
        try {
            s.checkPackageAccess("java.lang");
        } catch (Exception e) {
        }
        setSecurityManager0(s);
    }
    private static synchronized
    void setSecurityManager0(final SecurityManager s) {
        SecurityManager sm = getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission
                                     ("setSecurityManager"));
        }
        if ((s != null) && (s.getClass().getClassLoader() != null)) {      
            AccessController.doPrivileged(new PrivilegedAction<Object>() {
                public Object run() {
                    s.getClass().getProtectionDomain().implies
                        (SecurityConstants.ALL_PERMISSION);
                    return null;
                }
            });
        }
        security = s;
    }
	/** 毫秒 **/
	public static native long currentTimeMillis();
	/** 纳秒 **/
	public static native long nanoTime();
}
```

此外，在System中也提供了数组的复制功能
```
    public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
```
- @param      src  : 表示源数组（将要被复制的）
- @param      srcPos 复制src数组的起点
- @param      dest   目标数组，被改变的
- @param      destPos 目标数组的复制起点
- @param      length 复制目标数组的个数
例如：我们可以这样使用System.arraycopy(...)
int[] a = {1,2,3,4,5,6,7};
int[] b = {9,8,7,6};
System.arraycopy(a, 2, b,0,2)
b的结果为：[9,2,3,6]


此外，**System** 还提供了一个非常重要的特性，那就是**Properties props**

```
private static Properties props;
private static native Properties initProperties(Properties props);
```
下面这些属性，已经在JVM中被实现了:
- java.version ： java 版本号
- java.vendor ：Java供应商特定的字符串
- java.vendor.url：Java厂商的网址
- java.home  ： Java 安装目录
- java.class.version ： Java类版本号
- java.class.path  ：Java 类路径
- os.name  ： 操作系统的名称
- os.arch ： 操作系统的架构
- os.version  ： 操作系统的版本号
- file.separator  ： 文件分割符号
- path.separator  ： 路径分割符
- line.separator  ： 行分割符
- user.name ： 用户名称
- user.home ： 用户根目录
- user.dir  用户当前工作目录

我们一般会这样使用，同过System 可以有效的获取我们当前系统的环境的一些信息
```
System.getProperty("os.name");
```
其他的类似.

System 中还有这样的代码：
```
    public static void gc() {
        Runtime.getRuntime().gc();
    }
```
在执行System.gc() 的时候，会触发一下这样的JVM的垃圾回收。

总结：给出一套工具类的代码：
```

public class SystemUtils {
    
    /**
     * 系统默认字符集UTF-8。
     */
    public static final Charset DEFAULT_CHARSET = Charset.forName("utf-8");
    
    //内部引用，保证初始化。
    private static String lp;
    
    static {
        ByteArrayOutputStream bos = new ByteArrayOutputStream(2);
        PrintWriter writer = new PrintWriter(bos, true);
        writer.println();
        lp = new String(bos.toByteArray());
        writer.close();
        if(lp == null) {
            lp = new String(new byte[]{'\r','\n'});
        }
    }
    
    /**
     * lineSeparator
     */
    public static final String LINESEPARATOR = lp;
    
    /**
     * 获取当前JVM名称。
     * 
     * @return 当前JVM名称。
     */
    public static String getJavaVMName() {
        return System.getProperty("java.vm.name");
    }
    
    
    /**
     * 获取当前JVM版本。
     * 
     * @return  当前JVM版本。
     */
    public static String getJavaVMVersion() {
        return System.getProperty("java.vm.version");
    }
    
    /**
     * 获取当前JVM厂商。
     * 
     * @return 当前JVM厂商。
     */
    public static String getJavaVMVendor() {
        return System.getProperty("java.vm.vendor");
    }
    
    /**
     * 获取当前Java版本。
     * 
     * @return 当前Java版本。
     */
    public static String getJavaVersion() {
        return System.getProperty("java.version");
    }
    
    /**
     * 获取当前临时目录。
     * 
     * @return 系统当前临时目录。
     */
    public static String getTempDir() {
        return System.getProperty("java.io.tmpdir");
    }
    
    /**
     * 获取当前操作系统的名称。
     * 
     * @return  
     *      当前操作系统名称。
     */
    public static String getOsName() {
        return System.getProperty("os.name");
    }
    
    /**
     * 获取当前操作系统版本。
     * 
     * @return  
     *      当前操作系统版本。
     */
    public static String getOsVersion() {
        return System.getProperty("os.version");
    }
    
    /**
     * 获取当前系统用户名称。
     * 
     * @return  
     *      当前系统用户名称。
     */
    public static String getUserName() {
        return System.getProperty("user.name");
    }
    
    /**
     * 获取当前JavaHome。
     * 
     * @return  当前JavaHome, 如果没有则返回null。
     */
    public static String getJavaHome() {
        return System.getProperty("java.home");
    }
    
    /**
     * 获取CPU数据模型（32位还是64位，即寻址空间大小）。
     * 
     * @return 
     *      CPU数据模型（32位还是64位）。
     */
    public static String getArchDataMode() {
        return System.getProperty("sun.arch.data.model");
    }
    
    /**
     * 获取当前语言环境。
     * 
     * @return 当前语言环境，如：zh。
     */
    public static String getUserLanguage() {
        return System.getProperty("user.language");
    }
    
    /**
     * 获取文件分隔符。
     * 
     * @return 文件分隔符。
     */
    public static String getFileSeparator() {
        return System.getProperty("file.separator");
    }
    
    /**
     * 获取处理器数量（CPU核心数量）。
     * 
     * @return 处理器数量。
     */
    public static int getProcessorCount() {
        return Runtime.getRuntime().availableProcessors();
    }
    
    /**
     * 获取当前JVM空闲内存。
     * 
     * @return 当前JVM空闲内存，单位（字节）。
     */
    public static long getFreeMemory() {
        return Runtime.getRuntime().freeMemory();
    }
    
    /**
     * 获取当前JVM最大内存
     * 
     * @return 当前JVM最大内存，单位（字节）。
     */
    public static long getMaxMemory() {
        return  Runtime.getRuntime().maxMemory();
    }
    
    /**
     * <p>获取当前JVM总内存
     * <p>总内存可以不等于最大内存，取决于JVM的设置（参见-Xms -Xmx等参数），当
     * 最小内存不等于最大内存时，内存空间可扩展。
     * 
     * @return 
     */
    public static long getTotalMemory() {
        return Runtime.getRuntime().totalMemory();
    }
    
    /**
     * 打印当前所有线程栈追踪信息。
     */
    public static void printAllStackTrack() {
        Map<Thread, StackTraceElement[]> stMap = Thread.getAllStackTraces();
        for(Thread thread : stMap.keySet()) {
            StackTraceElement[] elements = stMap.get(thread);
            System.out.println(thread);
            for (StackTraceElement element : elements) {
                System.out.println("    "+element);
            }
        }
    }
    
    /**
     * 获取当前JVM运行时间（从启动到当前的时间）。
     * 
     * @return 
     *      当前JVM启动时间，单位（毫秒）。
     */     
    public static long getJavaVMUptime() {
        // throw new UnsupportedOperationException();  
        RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();
        if(runtimeMXBean != null){
                return runtimeMXBean.getUptime();
        }
        //can't happen
        return -1;        
    }
    
    /**
     * 获取当前JVM启动时间。
     * 
     * @return 
     *      当前JVM启动时间，单位（毫秒）。
     */
    public static long getJavaVMStartTime() {
        // throw new UnsupportedOperationException();  
        RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();
        if(runtimeMXBean != null){
                return runtimeMXBean.getStartTime();
        }
        //can't happen
        return -1;       
    }   
    
    private SystemUtils(){}
}

```


