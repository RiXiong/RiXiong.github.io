<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Tomcat多实例部署及其原理]]></title>
      <url>http://yoursite.com/2016/11/19/yunwei/1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>导读：<br>昨天在跟群友做技术交流的时候,了解到，有很多大公司都是采用了高可用的，分布式的，实例沉余1+台。但是在小公司的同学也很多，他们反映并不是所有公司都有那样的资源来供你调度。往往公司只会给你一台机器，因为有些应用挂了公司也不会有损失的，我们往往一台机器就可以搞定。<br>但是，我们也要为我们做出来的应用负责，毕竟东西做出来是为了给人用的，如果做出来的东西经常挂了，谈何使用，在前期，如果公司资源紧张的情况下，可以不可以做高可用，多机器的沉余部署。但是至少是在但机上有2个进程在跑。so,在这里我们就说说这个，如何做单机多实例的部署。<br>在这里谈谈，在只有单机的资源下，如何把单机的资源压榨出来，用好单机。</p>
</blockquote>
<hr>
<h1 id="1、Tomcat部署的场景分析"><a href="#1、Tomcat部署的场景分析" class="headerlink" title="1、Tomcat部署的场景分析"></a>1、Tomcat部署的场景分析</h1><p>通常，我们对tomcat单机部署需求可以分为几种：</p>
<ul>
<li>单实例单应用 (一个tomcat 一个web应用)</li>
<li>单实例多应用 (一个tomcat多个应用)</li>
<li>多实例单应用 (多个tomcat都部署一个应用)</li>
<li>多实例多应用 (多个tomcat部署多个不同的应用)</li>
</ul>
<p><strong>第一种场景</strong>：这是我们开发中经常用到的，如果不要求周期性地维护tomcat版本，一般的做法是把打好的war包丢到webapps目录下，然后执行startup.sh脚本，并且可以在浏览器里访问就行了。<br><strong>第二种场景</strong>：是把多个应用程序的war包放在同一个tomcat的webapps目录，这样一来，关闭和启动tomca，或tomcat挂掉会影响所有项目。<br><strong>第三种场景</strong>: 各个tomcat都运行同一个应用程序，对应地需要修改不同的监听端口，这种方式通常会和apache httpd或者nginx整合使用，做一些负载均衡的处理。<br><strong>第四种场景</strong>: 相当于第一种场景的复数形式，除了修改不同的监听端口，没有本质区别。</p>
<p>一般来说，多实例部署tomcat，可以充分利用系统资源，不过这种方式，也有几个方面需要考虑：<br>多实例tomcat的更新维护，例如对tomcat进行升级等操作，我们需要考虑如何能“优雅”地对所有实例进行升级<br>尽量不要影响应用程序，在更新tomcat时，一不小心就把conf目录等全部覆盖，所以尽量要把配置文件和安装目录隔离<br>对于单应用来说，如果将war包分别置于各个tomcat的webapps目录，那么在发布新版本的war时，可能会出现某个实例更新失败，导致用户在访问时可能会访问到不同版本的web app，因此，<strong>比较好的方式就是所有tomcat实例都统一指向同一个应用程序</strong>，这样做，就可以多个tomcat用一份应用源码，简单部署，单机高可用也能实现（要配合nginx）.<br>本文重点阐述多实例应用的部署方案，但是为了解决上述几个问题，我们需要先来了解一下tomcat的一些基本情况。</p>
<h1 id="2、我们的目标"><a href="#2、我们的目标" class="headerlink" title="2、我们的目标"></a>2、我们的目标</h1><p><a href="http://www.itnose.net/img/20161025/172338.png" target="_blank" rel="external"><img src="http://www.itnose.net/img/20161025/172338.png" alt="tomcat架构" title="title"></a></p>
<hr>
<h1 id="3、tomcat架构"><a href="#3、tomcat架构" class="headerlink" title="3、tomcat架构"></a>3、tomcat架构</h1><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p><a href="http://www.itnose.net/img/20160411/10674534.gif" target="_blank" rel="external"><img src="http://www.itnose.net/img/20160411/10674534.gif" alt="tomcat架构" title="title"></a></p>
<p>这里有一台服务器，3台tomcat服务，以及一台tomcat的解构图。</p>
<h2 id="分离目录"><a href="#分离目录" class="headerlink" title="分离目录"></a>分离目录</h2><table>
<thead>
<tr>
<th style="text-align:left">目录</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bin</td>
<td style="text-align:left">主要存放脚本文件，例如比较常用的windows和linux系统中启动和关闭脚本</td>
</tr>
<tr>
<td style="text-align:left">conf</td>
<td style="text-align:left">主要存放配置文件，其中最重要的两个配置文件是server.xml和web.xml</td>
</tr>
<tr>
<td style="text-align:left">lib</td>
<td style="text-align:left">主要存放tomcat运行所依赖的包</td>
</tr>
<tr>
<td style="text-align:left">logs</td>
<td style="text-align:left">主要存放运行时产生的日志文件，例如catalina.{date}.log等</td>
</tr>
<tr>
<td style="text-align:left">temp</td>
<td style="text-align:left">存放tomcat运行时产生的临时文件，例如开启了hibernate缓存的应用程序，会在该目录下生成一些文件</td>
</tr>
<tr>
<td style="text-align:left">webapps</td>
<td style="text-align:left">部署web应用程序的默认目录</td>
</tr>
<tr>
<td style="text-align:left">work</td>
<td style="text-align:left">主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件）</td>
</tr>
</tbody>
</table>
<p>再介绍两个tomcat中比较重要的概念（通常也是两个系统变量）——<strong>CATALINA_HOME</strong>和<strong>CATALINA_BASE</strong>：</p>
<p><strong>CATALINA_HOME</strong>：即指向Tomcat安装路径的系统变量<br><strong>CATALINA_BASE</strong>：即指向活跃配置路径的系统变量通过设置这两个变量，就可以将tomcat的安装目录和工作目录分离，从而实现tomcat多实例的部署。<br>Tomcat官方文档指出，CATALINA_HOME路径的路径下只需要包含bin和lib目录，这也就是支持tomcat软件运行的目录，而CATALINA_BASE设置的路径可以包括上述所有目录，不过其中bin和lib目录并不是必需的，缺省时会使用CATALINA_HOME中的bin和conf。如此，我们就可以使用一个tomcat安装目录部署多个tomcat实例，这样的好处在于方便升级，就可以在不影响tomcat实例的前提下，替换掉CATALINA_HOME指定的tomcat安装目录。</p>
<p><a href="http://www.itnose.net/img/20161025/172337.png" target="_blank" rel="external"><img src="http://www.itnose.net/img/20161025/172337.png" alt="tomcat架构" title="title"></a></p>
<p> tomcat serve.xml 配置结构<br>Container容器子容器间关系图<br><a href="http://www.itnose.net/img/20160411/10674535.png" target="_blank" rel="external"><img src="http://www.itnose.net/img/20160411/10674535.png" alt="tomcat架构" title="title"></a></p>
<p> 交互图<br><a href="http://www.itnose.net/img/20160411/10674536.png" target="_blank" rel="external"><img src="http://www.itnose.net/img/20160411/10674536.png" alt="tomcat架构" title="title"></a></p>
<p> 对比下Tomcat serve.xml 的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</div><div class="line"></div><div class="line">  &lt;GlobalNamingResources&gt;</div><div class="line">    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;</div><div class="line">              type=&quot;org.apache.catalina.UserDatabase&quot;</div><div class="line">              description=&quot;User database that can be updated and saved&quot;</div><div class="line">              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</div><div class="line">              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;</div><div class="line">  &lt;/GlobalNamingResources&gt;</div><div class="line">  &lt;Service name=&quot;Catalina&quot;&gt;</div><div class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</div><div class="line">               connectionTimeout=&quot;20000&quot;</div><div class="line">               redirectPort=&quot;8443&quot; /&gt;</div><div class="line">    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</div><div class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</div><div class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</div><div class="line">        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</div><div class="line">               resourceName=&quot;UserDatabase&quot;/&gt;</div><div class="line">      &lt;/Realm&gt;</div><div class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</div><div class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</div><div class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</div><div class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</div><div class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</div><div class="line">      &lt;/Host&gt;</div><div class="line">    &lt;/Engine&gt;</div><div class="line">  &lt;/Service&gt;</div><div class="line">&lt;/Server&gt;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="4、实战"><a href="#4、实战" class="headerlink" title="4、实战"></a>4、实战</h1><p>端口配置</p>
<h2 id="修改server-xml"><a href="#修改server-xml" class="headerlink" title="修改server.xml"></a>修改server.xml</h2><p>在server.xml中配置了四个监听端口，分别是：<br><strong>Server Port</strong>：该端口用于监听关闭tomcat的shutdown命令，<strong>默认为8005</strong>.<br><strong>Connector Port</strong>：该端口用于监听HTTP的请求，<strong>默认为8080</strong>.<br><strong>AJP Port</strong>：该端口用于监听AJP（ Apache JServ Protocol ）协议上的请求，通常用于整合Apache Server等其他HTTP服务器，<strong>默认为8009</strong><br><strong>Redirect Port</strong>：重定向端口，出现在Connector配置中，如果该Connector仅支持非SSL的普通http请求，那么该端口会把https的请求转发到这个Redirect Port指定的端口，<strong>默认为8443</strong></p>
<p>虚拟主机配置<br>再来说Host配置，Host就是所谓的虚拟主机，对应包含了一个或者多个web应用程序，默认的Host配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>其中：<br><strong>name</strong>： 虚拟主机的名称，一台主机表示了完全限定的域名或IP地址，<strong>默认为localhost</strong>，同时也是唯一的host，进入tomcat的所有http请求都会映射到该主机上<br><strong>appBase</strong>：web应用程序目录的路径，可以是CATALINA_HOME的相对路径，也可以写成绝对路径，<strong>默认情况下为$CATALINA_HOME/webappsunpackWARs</strong>： 表示是否自动解压war包<br><strong>autoDeploy</strong>：所谓的热部署，即在tomcat正在运行的情况下，如果有新的war加入，则会立即执行部署操作<br>另外再介绍一个Host中的属性—deployOnStartup：表示tomcat启动时是否自动部署appBase目录下所有的Web应用程序，默认为true。这个属性和autoDeploy会产生两次部署的“副作用”：一次是tomcat启动时就开始部署，第二次就是autoDeploy引起的热部署。因此最好将autoDeploy置为false<br>在部署<strong>多实例单应用</strong>的时候，默认的$CATALINA/webapps会因为tomcat安装目录升级产生不必要的麻烦，我们考虑将appBase的目录统一到另外的路径下。</p>
<p>Context的配置<br>最后再说明一下Context的配置，它出现在Host配置内，一个Context的配置就代表了一个web应用程序，如果配置多应用程序，就需要在Host下配置多个Context，一个简单的Context配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=&quot;/some&quot; docBase=&quot;someapp.war&quot; &gt;</div></pre></td></tr></table></figure></p>
<p><strong>path</strong>：表示访问入口，例如，path=”/abc”，则访问localhost:8080/abc时，就可以访问该Context对应的应用程序。如果path=””，则直接用localhost:8080就可以访问<br><strong>docBase</strong>：表示应用程序的解包目录或者war文件路径，是Host的appBase配置目录的相对路径，也可以是直接写成绝对路径，<strong>但是不要将appBase的值，作为docBase配置路径的前缀，例如appBase=”somedir”，docBase=”somedir-someapp.war”，这样的配置会导致部署错误</strong><br>通过配置Host的appBase和Context的docBase两个属性，可以将应用程序的文件和tomcat相关的目录进行分离，这样webapps目录也就没有作用了。</p>
<h2 id="跟我来实施该方案"><a href="#跟我来实施该方案" class="headerlink" title="跟我来实施该方案"></a>跟我来实施该方案</h2><ul>
<li>现在假设我们有一台已经配置好Java环境的服务器：（我用的是阿里云）</li>
<li>我已经有一个已经完成的shop.war 应用程序</li>
</ul>
<p>步骤1：<br>下载并解压tomcat<br><a href="/img/2016/11/tomcat01.jpg"><img src="/img/2016/11/tomcat01.jpg" alt="tomcat架构" title="title"></a></p>
<p>步骤2：<br>对Tomcat目录作以下调整：<br>在tomcat安装目录下创建a.ttlsa.com、b.ttlsa.com，并且将conf、logs、webapp、temp、work目录拷贝到这两个目录，然后tomcat安装目录只需要留下bin、a.ttlsa.com、b.ttlsa.com、lib这4个目录即可。配置后的目录结构如下：<br><a href="/img/2016/11/tomcat02.jpg"><img src="/img/2016/11/tomcat02.jpg" alt="tomcat架构" title="title"></a></p>
<p>如果要度tomcat 进行升级，我们只是需要对tomcat的lib 和 bin 目录进行升级即可。</p>
<p>步骤3：<br>配置站点server.xml<br>   <strong>配置a.ttlsa.com </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!-- 8005 改为8005 --&gt;</div><div class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</div><div class="line">  </div><div class="line">  &lt;GlobalNamingResources&gt;</div><div class="line">    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;</div><div class="line">              type=&quot;org.apache.catalina.UserDatabase&quot;</div><div class="line">              description=&quot;User database that can be updated and saved&quot;</div><div class="line">              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</div><div class="line">              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;</div><div class="line">  &lt;/GlobalNamingResources&gt;</div><div class="line">  </div><div class="line">  &lt;Service name=&quot;Catalina&quot;&gt;</div><div class="line">    &lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;</div><div class="line">               connectionTimeout=&quot;20000&quot;</div><div class="line">               redirectPort=&quot;8443&quot; /&gt;</div><div class="line">			   </div><div class="line">   &lt;!-- &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; --&gt;</div><div class="line">	</div><div class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</div><div class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</div><div class="line">        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</div><div class="line">               resourceName=&quot;UserDatabase&quot;/&gt;</div><div class="line">      &lt;/Realm&gt;</div><div class="line">	  &lt;!--</div><div class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</div><div class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</div><div class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</div><div class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</div><div class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</div><div class="line"></div><div class="line">      &lt;/Host&gt;</div><div class="line">	  --&gt;</div><div class="line"></div><div class="line">	  &lt;Host name=&quot;localhost&quot; appBase=&quot;F:\data\www\a.ttlsa.com&quot;</div><div class="line">			  unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;</div><div class="line">			  xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">			  &lt;Context path=&quot;&quot; docBase=&quot;&quot;  reloadable=&quot;true&quot;&gt;</div><div class="line">				&lt;valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; /&gt;</div><div class="line">			  &lt;/Context&gt;</div><div class="line">	   &lt;/Host&gt;</div><div class="line">	  </div><div class="line">    &lt;/Engine&gt;</div><div class="line">  &lt;/Service&gt;</div><div class="line">&lt;/Server&gt;</div></pre></td></tr></table></figure></p>
<p>配置b.ttlsa.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!-- 8005 改为8006 --&gt;</div><div class="line">&lt;Server port=&quot;8002&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;</div><div class="line">  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</div><div class="line">  </div><div class="line">  &lt;GlobalNamingResources&gt;</div><div class="line">    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;</div><div class="line">              type=&quot;org.apache.catalina.UserDatabase&quot;</div><div class="line">              description=&quot;User database that can be updated and saved&quot;</div><div class="line">              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</div><div class="line">              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;</div><div class="line">  &lt;/GlobalNamingResources&gt;</div><div class="line">  </div><div class="line">  &lt;Service name=&quot;Catalina&quot;&gt;</div><div class="line">    &lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot;</div><div class="line">               connectionTimeout=&quot;20000&quot;</div><div class="line">               redirectPort=&quot;8443&quot; /&gt;</div><div class="line">			   </div><div class="line">   &lt;!-- &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; --&gt;</div><div class="line">	</div><div class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</div><div class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</div><div class="line">        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</div><div class="line">               resourceName=&quot;UserDatabase&quot;/&gt;</div><div class="line">      &lt;/Realm&gt;</div><div class="line">	  &lt;!-- </div><div class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</div><div class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</div><div class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</div><div class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</div><div class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</div><div class="line"></div><div class="line">      &lt;/Host&gt;</div><div class="line">	  --&gt;</div><div class="line">	 </div><div class="line">	  &lt;Host name=&quot;localhost&quot; appBase=&quot;F:\data\www\a.ttlsa.com&quot;</div><div class="line">			  unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;</div><div class="line">			  xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</div><div class="line">			  &lt;Context path=&quot;&quot; docBase=&quot;&quot;  reloadable=&quot;true&quot;&gt;</div><div class="line">				&lt;valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; /&gt;</div><div class="line">			  &lt;/Context&gt;</div><div class="line">	   &lt;/Host&gt;</div><div class="line">	  </div><div class="line">    &lt;/Engine&gt;</div><div class="line">  &lt;/Service&gt;</div><div class="line">&lt;/Server&gt;</div></pre></td></tr></table></figure></p>
<p><strong>创建多实例启动脚本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># description: 启动tomcat多实例.#</div><div class="line">. /etc/init.d/functions</div><div class="line">RETVAL=$?</div><div class="line"># tomcat实例目录</div><div class="line">export CATALINA_BASE=&quot;$PWD&quot;</div><div class="line"># tomcat安装目录</div><div class="line">export CATALINA_HOME=&quot;/usr/local/tomcat-7.0.50&quot;</div><div class="line"># 可选</div><div class="line">export JVM_OPTIONS=&quot;-Xms128m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=512m&quot;</div><div class="line">case &quot;$1&quot; in</div><div class="line">start)</div><div class="line">if [ -f $CATALINA_HOME/bin/startup.sh ];then</div><div class="line">echo $&quot;Start Tomcat&quot;</div><div class="line">$CATALINA_HOME/bin/startup.sh</div><div class="line">fi</div><div class="line">;;</div><div class="line">stop)</div><div class="line">if [ -f $CATALINA_HOME/bin/shutdown.sh ];then</div><div class="line">echo $&quot;Stop Tomcat&quot;</div><div class="line">$CATALINA_HOME/bin/shutdown.sh</div><div class="line">fi</div><div class="line">;;</div><div class="line">*)</div><div class="line">echo $&quot;Usage: $0 &#123;start|stop&#125;&quot;</div><div class="line">exit 1</div><div class="line">;;</div><div class="line">esac</div><div class="line">exit $RETVAL</div></pre></td></tr></table></figure></p>
<p>这段shell 脚本比较简单，主要是设置环境变量，接受命令参数 RETVAL=$? ，来执行不同的命令。 RETVAL=start/stop 等<br>export CATALINA_BASE=”$PWD” 表示设置当前路径为  CATALINA_BASE 的环境变量，一般情况下CATALINA_BASE 和 CATALINA_HOME 是默认一样的。</p>
<p><strong>启动脚本赋权限</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># chmod a+x tomcat.sh</div></pre></td></tr></table></figure></p>
<h1 id="5、启动测试"><a href="#5、启动测试" class="headerlink" title="5、启动测试"></a>5、启动测试</h1><p>启动/关闭a.ttlsa.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">启动</div><div class="line"> # cd /usr/local/tomcat-7.0.50/a.ttlsa.com/</div><div class="line"> # ./tomcat.sh start</div><div class="line"> 关闭</div><div class="line"> # cd /usr/local/tomcat-7.0.50/a.ttlsa.com/</div><div class="line"> # ./tomcat.sh stop</div></pre></td></tr></table></figure></p>
<p> 启动/关闭b.ttlsa.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">启动</div><div class="line"> # cd /usr/local/tomcat-7.0.50/a.ttlsa.com/</div><div class="line"> # ./tomcat.sh start</div><div class="line"> 关闭</div><div class="line"> # cd /usr/local/tomcat-7.0.50/a.ttlsa.com/</div><div class="line"> # ./tomcat.sh stop</div></pre></td></tr></table></figure></p>
<p>备注：一定需要cd到tomcat.sh的当前目录下执行才可以</p>
<p>在win7 下，需要创建在a.ttlsa.com 和b.ttlsa.com下面创建 startup.bat 来启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">set JAVA_HOME=D:\Program Files\Java\jdk1.8.0_112</div><div class="line">set PATH=%JAVA_HOME%\bin;%PATH%</div><div class="line">set CATALINA_BASE=%CD%</div><div class="line">cd E:\tomcat-8.5.6\bin</div><div class="line">catalina.bat start</div></pre></td></tr></table></figure>
<p>这段是在win7 下云的bat脚本，于shell脚本同理，set CATALINA_BASE=%CD% 也是设置环境变量，CD 可以获取当前的路径。</p>
<p>shell 脚本入门参考：<a href="http://sishuok.com/forum/blogPost/list/5655.html" target="_blank" rel="external">http://sishuok.com/forum/blogPost/list/5655.html</a></p>
<h1 id="6、结果"><a href="#6、结果" class="headerlink" title="6、结果"></a>6、结果</h1><p>单个Tomcat应用多个tomcat实例的配置到此，就结束了。<br>此外，我们在这里的基础上进行系统的扩展，比如如果我的Tomcat应用挂掉了，我的整个应用都将不可用了，我们应该如何处理？<br>我们可以把Tomcat复制多份，在单机的情况下，开多一个Tomcat进程，在配合Nginx 来配置，就能实现Tomcat的自动切换，这些内容，有空再写。</p>
<p>如果需要操作多个实例显得比较麻烦，大家可以自行写统一的脚本。</p>
<p><a href="/img/2016/11/tomcat03.jpg"><img src="/img/2016/11/tomcat03.jpg" alt="tomcat架构" title="title"></a><br><a href="/img/2016/11/tomcat04.jpg"><img src="/img/2016/11/tomcat04.jpg" alt="tomcat架构" title="title"></a></p>
<p>Linux 下的实现基本一致。</p>
<p>这样的好处是，显而易见的，这样能开启Tomcat的多个进程，即多台tomcat，挂了也不太怕，还有其他tomcat应用支撑，代码实例我们发版本的时候，只需要发布一份，实例代码易于维护。<br>但是，我们网站的域名和端口一般是同一采用80端口，统一的域名，而现在我们开启tomcat只能一个使用80端口，显然是不合适的·，为此我们会引入负载均衡的nginx来配置。<br>nginx 采用80 端口，tomcat分别采用8080， 8081， 8082 这样就能让我们的程序稳定的运行。<br>这样，我们就能进最大的限度来压榨单机的性能，保证应用程序的稳定的运行。<br>而然，单机不然有单机的瓶颈，毕竟单机中的cpu 已经各种硬件的限制，会大大影响实例程序的跑动，在这时，就不再是单机能抗的动的了，我们需要分析程序的瓶颈在那？数据库，那就把数据库单独分出去，单独一台机器，是文件图片服务器，就把他分出去。如果是应用程序太大，就要考虑把应用实例进行拆解为不同哦那个的组件，单独部署，这就是分布式部署。<br>当然，这都是后话，只有程序复杂到一定的程度，并体量很大的话，才会做这种架构的演变，成本和技术投入的难度也会相应的变大。<br>本章，只局限于如何玩好单机的基础上来讨论，对于分布式的那块，笔者能力有限，尚且还不能完全驾驭，不做分享。</p>
<h1 id="7、nginx-tomcat热备"><a href="#7、nginx-tomcat热备" class="headerlink" title="7、nginx+tomcat热备"></a>7、nginx+tomcat热备</h1><p>在上面的配置的基础上，我们在进一步进行扩展，进行实例的均衡和热备。<br>可以在一个服务器挂了的情况下连到另外一个，那怎么弄呢？<br>其实很简单，在upstream中的local_tomcat中配置多一个server。<br>在上面，我的a.ttlsa.com  和 b.ttlsa.com 都是访问  F:\data\www\a.ttlsa.com 下的源码的index.jsp 页面,<br>为了能观察，nginx 的keepAlive 的效果，我做一下修改：<br>a.ttlsa.com —&gt; F:\data\www\a.ttlsa.com  index.jsp 中文字是 1<br>b.ttlsa.com —&gt; F:\data\www\b.ttlsa.com  index.jsp 中文字是 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream local_tomcat &#123;  </div><div class="line">	server localhost:8081 weight=1;  </div><div class="line">	server localhost:8082 weight=5;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  server &#123;</div><div class="line">      listen       80;</div><div class="line">      server_name  localhost:8081;</div><div class="line"></div><div class="line">      #charset koi8-r;</div><div class="line"></div><div class="line">      #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">      #location / &#123;</div><div class="line">      #    root   html;</div><div class="line">      #    index  index.html index.htm;</div><div class="line">      #&#125;		</div><div class="line">location / &#123;  </div><div class="line">	proxy_pass http://local_tomcat;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="/img/2016/11/tomcat05.gif"><img src="/img/2016/11/tomcat05.gif" alt="tomcat架构" title="title"></a></p>
<p>在通常的情况下，我们一般是指向一份源码就足够了，并且设置权值，减轻应用的压力。同时也不会出现单点的情况。</p>
<p>补充：nginx.con 配置</p>
<pre><code>#user  nobody;
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    upstream local_tomcat {  
        server localhost:8081 weight=1;  
        server localhost:8082 weight=5;  
    } 

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}        
        location / {  
            proxy_pass http://local_tomcat;  
        }  

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

}
</code></pre><blockquote>
<p>参考文章：<br><a href="http://www.cnblogs.com/tq03/p/3507658.html" target="_blank" rel="external">http://www.cnblogs.com/tq03/p/3507658.html</a><br><a href="http://www.itnose.net/detail/6658488.html" target="_blank" rel="external">http://www.itnose.net/detail/6658488.html</a><br><a href="http://www.ttlsa.com/tomcat/config-multi-tomcat-instance/" target="_blank" rel="external">http://www.ttlsa.com/tomcat/config-multi-tomcat-instance/</a><br><a href="http://www.cnblogs.com/_popc/p/4167516.html" target="_blank" rel="external">http://www.cnblogs.com/_popc/p/4167516.html</a><br><a href="http://www.itnose.net/detail/6485584.html" target="_blank" rel="external">http://www.itnose.net/detail/6485584.html</a><br><a href="http://www.itnose.net/detail/6521677.html" target="_blank" rel="external">http://www.itnose.net/detail/6521677.html</a><br><a href="http://www.itnose.net/detail/6448554.html" target="_blank" rel="external">http://www.itnose.net/detail/6448554.html</a><br><a href="http://www.aikaiyuan.com/7907.html" target="_blank" rel="external">http://www.aikaiyuan.com/7907.html</a><br><a href="http://blog.csdn.net/cclovett/article/details/26377269" target="_blank" rel="external">http://blog.csdn.net/cclovett/article/details/26377269</a> (nginx)</p>
</blockquote>
<hr>
<p><a href="/css/images/mm_facetoface_collect.png"><img src="/css/images/mm_facetoface_collect.png" alt="tomcat架构" title="title"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java.security源码解读系列-运用加密技术保护Java源代码]]></title>
      <url>http://yoursite.com/2016/11/18/jca/00/</url>
      <content type="html"><![CDATA[<blockquote>
<p>导读：</p>
<ul>
<li>这是个人阅读jdk 源码的一个系列，java.security时写的文章，希望写该篇文章，能加深自己对于java语言的理解。</li>
<li>本文相关的JDK版本是JDK7,jdk8</li>
</ul>
</blockquote>
<hr>
<h1 id="为什么要加密？"><a href="#为什么要加密？" class="headerlink" title="为什么要加密？"></a>为什么要加密？</h1><p>对于传统的C或C++之类的语言来说，要在Web上保护源代码是很容易的，只要不发布它就可以。遗憾的是，Java程序的源代码很容易被别人偷看。只要有一个反编译器，任何人都可以分析别人的代码。Java的灵活性使得源代码很容易被窃取，但与此同时，它也使通过加密保护代码变得相对容易，我们唯一需要了解的就是Java的ClassLoader对象。当然，在加密过程中，有关Java Cryptography Extension（JCE）的知识也是必不可少的。</p>
<p>有几种技术可以“模糊”Java类文件，使得反编译器处理类文件的效果大打折扣。然而，修改反编译器使之能够处理这些经过模糊处理的类文件并不是什么难事，所以不能简单地依赖模糊技术来保证源代码的安全。</p>
<p>我们可以用流行的加密工具加密应用，比如PGP（Pretty Good Privacy）或GPG（GNU Privacy Guard）。这时，最终用户在运行应用之前必须先进行解密。但解密之后，最终用户就有了一份不加密的类文件，这和事先不进行加密没有什么差别。</p>
<p>Java运行时装入字节码的机制隐含地意味着可以对字节码进行修改。JVM每次装入类文件时都需要一个称为ClassLoader的对象，这个对象负责把新的类装入正在运行的JVM。JVM给ClassLoader一个包含了待装入类（比如java.lang.Object）名字的字符串，然后由ClassLoader负责找到类文件，装入原始数据，并把它转换成一个Class对象。</p>
<p>我们可以通过定制ClassLoader，在类文件执行之前修改它。这种技术的应用非常广泛――在这里，它的用途是在类文件装入之时进行解密，因此可以看成是一种即时解密器。由于解密后的字节码文件永远不会保存到文件系统，所以窃密者很难得到解密后的代码。</p>
<p>由于把原始字节码转换成Class对象的过程完全由系统负责，所以创建定制ClassLoader对象其实并不困难，只需先获得原始数据，接着就可以进行包含解密在内的任何转换。</p>
<p>Java 2在一定程度上简化了定制ClassLoader的构建。在Java 2中，loadClass的缺省实现仍旧负责处理所有必需的步骤，但为了顾及各种定制的类装入过程，它还调用一个新的findClass方法。</p>
<p>这为我们编写定制的ClassLoader提供了一条捷径，减少了麻烦：只需覆盖findClass，而不是覆盖loadClass。这种方法避免了重复所有装入器必需执行的公共步骤，因为这一切由loadClass负责。</p>
<p>不过，本文的定制ClassLoader并不使用这种方法。原因很简单。如果由默认的ClassLoader先寻找经过加密的类文件，它可以找到；但由于类文件已经加密，所以它不会认可这个类文件，装入过程将失败。因此，我们必须自己实现loadClass，稍微增加了一些工作量。</p>
<hr>
<h1 id="定制类装入器"><a href="#定制类装入器" class="headerlink" title="定制类装入器"></a>定制类装入器</h1><p>每一个运行着的JVM已经拥有一个ClassLoader。这个默认的ClassLoader根据CLASSPATH环境变量的值，在本地文件系统中寻找合适的字节码文件。</p>
<p>应用定制ClassLoader要求对这个过程有较为深入的认识。我们首先必须创建一个定制ClassLoader类的实例，然后显式地要求它装入另外一个类。这就强制JVM把该类以及所有它所需要的类关联到定制的ClassLoader。Listing 1显示了如何用定制ClassLoader装入类文件。<br>【Listing 1：利用定制的ClassLoader装入类文件】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/** 首先创建一个ClassLoader对象 **/</div><div class="line">ClassLoader myClassLoader = new myClassLoader();</div><div class="line">/** 利用定制ClassLoader对象装入类文件 **/</div><div class="line">/** 并把它转换成Class对象 **/</div><div class="line">Class myClass = myClassLoader.loadClass( &quot;mypackage.MyClass&quot; );</div><div class="line">/** 最后，创建该类的一个实例 **/</div><div class="line">Object newInstance = myClass.newInstance();</div><div class="line">/** 注意，MyClass所需要的所有其他类，都将通过 **</div><div class="line">/** 定制的ClassLoader自动装入 **/</div></pre></td></tr></table></figure></p>
<p>如前所述，定制ClassLoader只需先获取类文件的数据，然后把字节码传递给运行时系统，由后者完成余下的任务。</p>
<p>ClassLoader有几个重要的方法。创建定制的ClassLoader时，我们只需覆盖其中的一个，即loadClass，提供获取原始类文件数据的代码。这个方法有两个参数：类的名字，以及一个表示JVM是否要求解析类名字的标记（即是否同时装入有依赖关系的类）。如果这个标记是true，我们只需在返回JVM之前调用resolveClass。</p>
<p>【Listing 2：ClassLoader.loadClass()的一个简单实现】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">    public Class loadClass( String name, boolean resolve )</div><div class="line">    throws ClassNotFoundException &#123;</div><div class="line">  try &#123;</div><div class="line">    /** 我们要创建的Class对象 **/</div><div class="line">     Class clasz = null;</div><div class="line">    /** 必需的步骤1：如果类已经在系统缓冲之中，**/</div><div class="line">    /** 我们不必再次装入它 **/</div><div class="line">    clasz = findLoadedClass( name );</div><div class="line">    if (clasz != null)</div><div class="line">      return clasz;</div><div class="line">    /** 下面是定制部分 **/</div><div class="line">    byte classData[] = /* 通过某种方法获取字节码数据 */;</div><div class="line">    if (classData != null) &#123;</div><div class="line">      /** 成功读取字节码数据，现在把它转换成一个Class对象 **/</div><div class="line">      clasz = defineClass( name, classData, 0, classData.length );</div><div class="line">    &#125;</div><div class="line">    /** 必需的步骤2：如果上面没有成功，**/</div><div class="line">    /** 我们尝试用默认的ClassLoader装入它 **/</div><div class="line">    if (clasz == null)</div><div class="line">      clasz = findSystemClass( name );</div><div class="line">    /** 必需的步骤3：如有必要，则装入相关的类 **/</div><div class="line">    if (resolve &amp;&amp; clasz != null)</div><div class="line">      resolveClass( clasz );</div><div class="line">    /** 把类返回给调用者 **/</div><div class="line">    return clasz;</div><div class="line">  &#125; catch( IOException ie ) &#123;</div><div class="line">    throw new ClassNotFoundException( ie.toString() );</div><div class="line">  &#125; catch( GeneralSecurityException gse ) &#123;</div><div class="line">    throw new ClassNotFoundException( gse.toString() );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Listing 2显示了一个简单的loadClass实现。代码中的大部分对所有ClassLoader对象来说都一样，但有一小部分（已通过注释标记）是特有的。在处理过程中，ClassLoader对象要用到其他几个辅助方法：</p>
<ul>
<li>findLoadedClass：用来进行检查，以便确认被请求的类当前还不存在。loadClass方法应该首先调用它。</li>
<li>defineClass：获得原始类文件字节码数据之后，调用defineClass把它转换成一个Class对象。任何loadClass实现都必须调用这个方法。</li>
<li>findSystemClass：提供默认ClassLoader的支持。如果用来寻找类的定制方法不能找到指定的类（或者有意地不用定制方法），则可以调用该方法尝试默认的装入方式。这是很有用的，特别是从普通的JAR文件装入标准Java类时。</li>
<li>resolveClass：当JVM想要装入的不仅包括指定的类，而且还包括该类引用的所有其他类时，它会把loadClass的resolve参数设置成true。这时，我们必须在返回刚刚装入的Class对象给调用者之前调用resolveClass。</li>
</ul>
<hr>
<h1 id="加密、解密"><a href="#加密、解密" class="headerlink" title="加密、解密"></a>加密、解密</h1><p>Java加密扩展即Java Cryptography Extension，简称JCE。它是Sun的加密服务软件，包含了加密和密匙生成功能。JCE是JCA（Java Cryptography Architecture）的一种扩展。</p>
<p>JCE没有规定具体的加密算法，但提供了一个框架，加密算法的具体实现可以作为服务提供者加入。除了JCE框架之外，JCE软件包还包含了SunJCE服务提供者，其中包括许多有用的加密算法，比如DES（Data Encryption Standard）和Blowfish。</p>
<p>为简单计，在本文中我们将用DES算法加密和解密字节码。下面是用JCE加密和解密数据必须遵循的基本步骤：</p>
<ul>
<li>步骤1：生成一个安全密匙。在加密或解密任何数据之前需要有一个密匙。密匙是随同被加密的应用一起发布的一小段数据，Listing 3显示了如何生成一个密匙。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* DES算法要求有一个可信任的随机数源 */</div><div class="line">SecureRandom sr = new SecureRandom();</div><div class="line">/* 为我们选择的DES算法生成一个KeyGenerator对象 */</div><div class="line">KeyGenerator kg = KeyGenerator.getInstance( &quot;DES&quot; );</div><div class="line">kg.init( sr );</div><div class="line">/*生成密匙 */</div><div class="line">SecretKey key = kg.generateKey();</div><div class="line">/* 获取密匙数据 */</div><div class="line">byte rawKeyData[] = key.getEncoded();</div><div class="line">/* 接下来就可以用密匙进行加密或解密，或者把它保存</div><div class="line">   为文件供以后使用 */</div><div class="line">doSomething( rawKeyData );</div></pre></td></tr></table></figure>
<ul>
<li>步骤2：加密数据。得到密匙之后，接下来就可以用它加密数据。除了解密的ClassLoader之外，一般还要有一个加密待发布应用的独立程序（见Listing 4）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/* DES算法要求有一个可信任的随机数源 */</div><div class="line">SecureRandom sr = new SecureRandom();</div><div class="line">byte rawKeyData[] = /* 用某种方法获得密匙数据 */;</div><div class="line">/* 从原始密匙数据创建DESKeySpec对象 */</div><div class="line">DESKeySpec dks = new DESKeySpec( rawKeyData );</div><div class="line">/* 创建一个密匙工厂，然后用它把DESKeySpec转换成 */</div><div class="line">/* 一个SecretKey对象 */</div><div class="line">SecretKeyFactory keyFactory = SecretKeyFactory.getInstance( &quot;DES&quot; );</div><div class="line">SecretKey key = keyFactory.generateSecret( dks );</div><div class="line">/* Cipher对象实际完成加密操作 */</div><div class="line">Cipher cipher = Cipher.getInstance( &quot;DES&quot; );</div><div class="line">/* 用密匙初始化Cipher对象 */</div><div class="line">cipher.init( Cipher.ENCRYPT_MODE, key, sr );</div><div class="line">/* 现在，获取数据并加密 */</div><div class="line">byte data[] = /* 用某种方法获取数据 */</div><div class="line">/* 正式执行加密操作 */</div><div class="line">byte encryptedData[] = cipher.doFinal( data );</div><div class="line">/* 进一步处理加密后的数据 */</div><div class="line">doSomething( encryptedData );</div></pre></td></tr></table></figure>
<ul>
<li>步骤3：解密数据。运行经过加密的应用时，ClassLoader分析并解密类文件。操作步骤如Listing 5所示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/* DES算法要求有一个可信任的随机数源 */</div><div class="line">SecureRandom sr = new SecureRandom();</div><div class="line">byte rawKeyData[] = /* 用某种方法获取原始密匙数据 */;</div><div class="line">/* 从原始密匙数据创建一个DESKeySpec对象 */</div><div class="line">DESKeySpec dks = new DESKeySpec( rawKeyData );</div><div class="line">/* 创建一个密匙工厂，然后用它把DESKeySpec对象转换成 */</div><div class="line">/* 一个SecretKey对象 */</div><div class="line">SecretKeyFactory keyFactory = SecretKeyFactory.getInstance( &quot;DES&quot; );</div><div class="line">SecretKey key = keyFactory.generateSecret( dks );</div><div class="line">/* Cipher对象实际完成解密操作 */</div><div class="line">Cipher cipher = Cipher.getInstance( &quot;DES&quot; );</div><div class="line">/* 用密匙初始化Cipher对象 */</div><div class="line">cipher.init( Cipher.DECRYPT_MODE, key, sr );</div><div class="line">/* 现在，获取数据并解密 */</div><div class="line">byte encryptedData[] = /* 获得经过加密的数据 */</div><div class="line">/* 正式执行解密操作 */</div><div class="line">byte decryptedData[] = cipher.doFinal( encryptedData );</div><div class="line">/* 进一步处理解密后的数据 */</div><div class="line">doSomething( decryptedData );</div></pre></td></tr></table></figure>
<hr>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>前面介绍了如何加密和解密数据。要部署一个经过加密的应用，步骤如下：</p>
<ul>
<li>1、步骤1：创建应用。我们的例子包含一个App主类，两个辅助类（分别称为Foo和Bar）。这个应用没有什么实际功用，但只要我们能够加密这个应用，加密其他应用也就不在话下。</li>
<li>2、步骤2：生成一个安全密匙。在命令行，利用GenerateKey工具（参见GenerateKey.java）把密匙写入一个文件：<br>   % java GenerateKey key.data</li>
<li>3、步骤3：加密应用。在命令行，利用EncryptClasses工具（参见EncryptClasses.java）加密应用的类：<br>   % java EncryptClasses key.data App.class Foo.class Bar.class<br>该命令把每一个.class文件替换成它们各自的加密版本</li>
</ul>
<p>步骤4：运行经过加密的应用。用户通过一个DecryptStart程序运行经过加密的应用。DecryptStart程序如Listing 6所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line">import java.security.*;</div><div class="line">import java.lang.reflect.*;</div><div class="line">import javax.crypto.*;</div><div class="line">import javax.crypto.spec.*;</div><div class="line">public class DecryptStart extends ClassLoader</div><div class="line">&#123;</div><div class="line">  /* 这些对象在构造函数中设置， */</div><div class="line">  /* 以后loadClass()方法将利用它们解密类 */</div><div class="line">  private SecretKey key;</div><div class="line">  private Cipher cipher;</div><div class="line">  /* 构造函数：设置解密所需要的对象 */</div><div class="line">  public DecryptStart( SecretKey key ) throws GeneralSecurityException,</div><div class="line">      IOException &#123;</div><div class="line">    this.key = key;</div><div class="line">    String algorithm = &quot;DES&quot;;</div><div class="line">    SecureRandom sr = new SecureRandom();</div><div class="line">    System.err.println( &quot;[DecryptStart: creating cipher]&quot; );</div><div class="line">    cipher = Cipher.getInstance( algorithm );</div><div class="line">    cipher.init( Cipher.DECRYPT_MODE, key, sr );</div><div class="line">  &#125;</div><div class="line">  /* main过程：我们要在这里读入密匙，创建DecryptStart的 */</div><div class="line">  /* 实例，它就是我们的定制ClassLoader。 */</div><div class="line">  /* 设置好ClassLoader以后，我们用它装入应用实例， */</div><div class="line">  /* 最后，我们通过Java Reflection API调用应用实例的main方法 */</div><div class="line">  static public void main( String args[] ) throws Exception &#123;</div><div class="line">    String keyFilename = args[0];</div><div class="line">    String appName = args[1];</div><div class="line">     /* 这些是传递给应用本身的参数 */</div><div class="line">    String realArgs[] = new String[args.length-2];</div><div class="line">    System.arraycopy( args, 2, realArgs, 0, args.length-2 );</div><div class="line">    /* 读取密匙 */</div><div class="line">    System.err.println( &quot;[DecryptStart: reading key]&quot; );</div><div class="line">    byte rawKey[] = Util.readFile( keyFilename );</div><div class="line">    DESKeySpec dks = new DESKeySpec( rawKey );</div><div class="line">    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance( &quot;DES&quot; );</div><div class="line">    SecretKey key = keyFactory.generateSecret( dks );</div><div class="line">    /* 创建解密的ClassLoader */</div><div class="line">    DecryptStart dr = new DecryptStart( key );</div><div class="line">    /* 创建应用主类的一个实例 */</div><div class="line">    /* 通过ClassLoader装入它 */</div><div class="line">    System.err.println( &quot;[DecryptStart: loading &quot;+appName+&quot;]&quot; );</div><div class="line">    Class clasz = dr.loadClass( appName );</div><div class="line">    /* 最后，通过Reflection API调用应用实例 */</div><div class="line">    /* 的main()方法 */</div><div class="line">    /* 获取一个对main()的引用 */</div><div class="line">    String proto[] = new String[1];</div><div class="line">    Class mainArgs[] = &#123; (new String[1]).getClass() &#125;;</div><div class="line">    Method main = clasz.getMethod( &quot;main&quot;, mainArgs );</div><div class="line">    /* 创建一个包含main()方法参数的数组 */</div><div class="line">    Object argsArray[] = &#123; realArgs &#125;;</div><div class="line">    System.err.println( &quot;[DecryptStart: running &quot;+appName+&quot;.main()]&quot; );</div><div class="line">    /* 调用main() */</div><div class="line">    main.invoke( null, argsArray );</div><div class="line">  &#125;</div><div class="line">  public Class loadClass( String name, boolean resolve )</div><div class="line">      throws ClassNotFoundException &#123;</div><div class="line">    try &#123;</div><div class="line">      /* 我们要创建的Class对象 */</div><div class="line">      Class clasz = null;</div><div class="line">      /* 必需的步骤1：如果类已经在系统缓冲之中 */</div><div class="line">      /* 我们不必再次装入它 */</div><div class="line">      clasz = findLoadedClass( name );</div><div class="line">      if (clasz != null)</div><div class="line">        return clasz;</div><div class="line">      /* 下面是定制部分 */</div><div class="line">      try &#123;</div><div class="line">        /* 读取经过加密的类文件 */</div><div class="line">        byte classData[] = Util.readFile( name+&quot;.class&quot; );</div><div class="line">        if (classData != null) &#123;</div><div class="line">          /* 解密... */</div><div class="line">          byte decryptedClassData[] = cipher.doFinal( classData );</div><div class="line">          /* 再把它转换成一个类 */</div><div class="line">          clasz = defineClass( name, decryptedClassData,</div><div class="line">            0, decryptedClassData.length );</div><div class="line">          System.err.println( &quot;[DecryptStart: decrypting class &quot;+name+&quot;]&quot; );</div><div class="line">        &#125;</div><div class="line">      &#125; catch( FileNotFoundException fnfe ) &#123;</div><div class="line">      &#125;</div><div class="line">      /* 必需的步骤2：如果上面没有成功 */</div><div class="line">      /* 我们尝试用默认的ClassLoader装入它 */</div><div class="line">      if (clasz == null)</div><div class="line">        clasz = findSystemClass( name );</div><div class="line">      /* 必需的步骤3：如有必要，则装入相关的类 */</div><div class="line">      if (resolve &amp;&amp; clasz != null)</div><div class="line">        resolveClass( clasz );</div><div class="line">      /* 把类返回给调用者 */</div><div class="line">      return clasz;</div><div class="line">    &#125; catch( IOException ie ) &#123;</div><div class="line">      throw new ClassNotFoundException( ie.toString()</div><div class="line">);</div><div class="line">    &#125; catch( GeneralSecurityException gse ) &#123;</div><div class="line">      throw new ClassNotFoundException( gse.toString()</div><div class="line">);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于未经加密的应用，正常执行方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">% java App arg0 arg1 arg2</div></pre></td></tr></table></figure>
<p>对于经过加密的应用，则相应的运行方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">% java DecryptStart key.data App arg0 arg1 arg2</div></pre></td></tr></table></figure>
<p>DecryptStart有两个目的。一个DecryptStart的实例就是一个实施即时解密操作的定制ClassLoader；同时，DecryptStart还包含一个main过程，它创建解密器实例并用它装入和运行应用。示例应用App的代码包含在App.java、Foo.java和Bar.java内。Util.java是一个文件I/O工具，本文示例多处用到了它。完整的代码请从本文最后下载。</p>
<hr>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>我们看到，要在不修改源代码的情况下加密一个Java应用是很容易的。不过，世上没有完全安全的系统。本文的加密方式提供了一定程度的源代码保护，但对某些攻击来说它是脆弱的。<br>虽然应用本身经过了加密，但启动程序DecryptStart没有加密。攻击者可以反编译启动程序并修改它，把解密后的类文件保存到磁盘。降低这种风险的办法之一是对启动程序进行高质量的模糊处理。或者，启动程序也可以采用直接编译成机器语言的代码，使得启动程序具有传统执行文件格式的安全性。<br>另外还要记住的是，大多数JVM本身并不安全。狡猾的黑客可能会修改JVM，从ClassLoader之外获取解密后的代码并保存到磁盘，从而绕过本文的加密技术。Java没有为此提供真正有效的补救措施。<br>不过应该指出的是，所有这些可能的攻击都有一个前提，这就是攻击者可以得到密匙。如果没有密匙，应用的安全性就完全取决于加密算法的安全性。虽然这种保护代码的方法称不上十全十美，但它仍不失为一种保护知识产权和敏感用户数据的有效方案。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）</a><br><a href="http://m635674608.iteye.com/blog/1844777（强推荐）" target="_blank" rel="external">http://m635674608.iteye.com/blog/1844777（强推荐）</a><br><a href="http://joshuasabrina.iteye.com/blog/1798245（强推荐）" target="_blank" rel="external">http://joshuasabrina.iteye.com/blog/1798245（强推荐）</a><br><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）</a><br><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）</a><br><a href="http://www.cnblogs.com/NullPointException/p/5054082.html" target="_blank" rel="external">http://www.cnblogs.com/NullPointException/p/5054082.html</a><br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[机器学习]]></title>
      <url>http://yoursite.com/2016/11/12/rob/rob/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/im-qq/webqq-core" target="_blank" rel="external">webqq-core</a><br><a href="https://github.com/b3log/xiaov" target="_blank" rel="external">xiaov</a><br><a href="https://github.com/im-qq/webqq-core" target="_blank" rel="external">https://github.com/im-qq/webqq-core</a></p>
<p><a href="https://code.google.com/archive/p/iqq/" target="_blank" rel="external">https://code.google.com/archive/p/iqq/</a><br><a href="http://pan.baidu.com/share/home?uk=3071047022" target="_blank" rel="external">http://pan.baidu.com/share/home?uk=3071047022</a><br><a href="https://hacpai.com/article/1467011936362" target="_blank" rel="external">https://hacpai.com/article/1467011936362</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java.security源码解读系列-PKI]]></title>
      <url>http://yoursite.com/2016/11/12/jca/02/</url>
      <content type="html"><![CDATA[<blockquote>
<p>导读：</p>
<ul>
<li>这是个人阅读jdk 源码的一个系列，java.security时写的文章，希望写该篇文章，能加深自己对于java语言的理解。</li>
<li>本文相关的JDK版本是JDK7,jdk8</li>
</ul>
</blockquote>
<p>在翻看，jce 的源码中，笔者发现，jce中的源码都基本引用到了java.security 下的类；<br>通过上篇的导读，我们基本可以了解java.security 的基本架构的主要组成：</p>
<ul>
<li>PKI (public key infrastructure)</li>
<li>认证(authentication)</li>
<li>安全通信(secure conmmunication)</li>
<li>访问控制(access control)</li>
</ul>
<h1 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h1><p>PKI —— 公钥基础构件<br><strong>PKI</strong>是一个术语，主要用于描述一类基于公钥的安全信息交互框架。它允许identity，比如人或者组织，绑定在数字证书上，并且提供一种验证证书的方法。PKI包括了密钥、证书、公钥加密和可信的证书颁发机构(CAs，用于生成和签署证书)。<br>Java平台提供API和provider支持X.509、CRLs、PKIX证书路径的构建和验证。<br>java Security API提供了可互操作的算法和安全服务的实现。服务以provider的形式实现，可以以插件的形式植入应用程序中。程序员可以透明地使用这些服务，如此使得程序员可以集中精力在如何把安全组件集成到自己的应用程序中，而不是去实现这些安全功能。<br>既然Provider 是如此总要的，好奇的我总是要去看看的：<br>看到该类的作者是：本杰明雷诺（Benjamin Renaud） 和 安德烈亚斯斯特本兹（Andreas Sterbenz）<br><strong>PKI</strong>相关的类可以在<strong>java.security</strong>和<strong>java.security.cert</strong>包下获取。</p>
<h1 id="PKI的组成"><a href="#PKI的组成" class="headerlink" title="PKI的组成"></a>PKI的组成</h1><ul>
<li><strong>密匙 key</strong></li>
<li><strong>证书 certificate</strong></li>
<li><strong>公钥加密 Public key encryption（PKE）</strong></li>
<li><strong>可信的证书颁发机构 CAS</strong></li>
</ul>
<p>下面我们来说说密钥：<br>密钥在jdk 中，她主要是是通过 key store 来实现，相关涉及的类都是 XXkeyXX 这类的形式。我们先看看java.security.KeyStore类，在该类的类头部，注释已经说明她是一个用来存储密钥和证书的类或叫数据解构更加合适。<br>在KeyStore中包含了好几个内部类，蛮有意思的，包括Builder内部类数据解构的构建者，<br><strong>CallbackHandlerProtection</strong>,<br><strong>PasswordParameter</strong>,<br><strong>PrivateKeyEntry</strong>, 私钥，一个存储加密过的私钥，用来存储保护的信息，防止非法访问。<br><strong>SecretKeyEntry</strong>, 密钥<br><strong>SimpleLoadStoreParameter</strong>,<br><strong>TrustedCeritificateEntry</strong> 可信任证书，他包含一个单一的公钥，可以供给别人使用，我们称为可信任证书</p>
<p>要学习如何看源码，看源码的注释是必不可少的，幸运的是JKD的源码注释是那么的清晰。哈哈，感谢前人的努力。<br><strong>KeyStore</strong>是用来存储加密密钥和加密证书的存储解构，类的表头注释来了个开门见山。<br><strong>KeyStore</strong>可以支持不同的实体类型的存储结构，每一个类型都实现了内部的一个KeyStore.Entry 接口。<br>它支持一下的几种存储解构类型：</p>
<ul>
<li><strong>KeyStore.PrivateKeyEntry</strong><blockquote>
<p>这个存储解构持有 加密的 <strong>PrivateKey</strong>(私钥)，用来存储一个被保护的格式数据，防止被接近访问。同时他也会实现一个对公钥开放的证书链来供外部访问。<br>私钥和证书主要是个一个已经被授权的应用来访问私钥和证书链的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public static final class PrivateKeyEntry implements Entry &#123;</div><div class="line"></div><div class="line">    private final PrivateKey privKey; </div><div class="line">		</div><div class="line">    private final Certificate[] chain;</div><div class="line">    private final Set&lt;Attribute&gt; attributes;</div><div class="line"></div><div class="line">    public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain) &#123;</div><div class="line">        this(privateKey, chain, Collections.&lt;Attribute&gt;emptySet());</div><div class="line">    &#125;</div><div class="line">    public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain,</div><div class="line">       Set&lt;Attribute&gt; attributes) &#123;</div><div class="line"></div><div class="line">        if (privateKey == null || chain == null || attributes == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;invalid null input&quot;);</div><div class="line">        &#125;</div><div class="line">        if (chain.length == 0) &#123;</div><div class="line">            throw new IllegalArgumentException</div><div class="line">                            (&quot;invalid zero-length input chain&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Certificate[] clonedChain = chain.clone();</div><div class="line">        String certType = clonedChain[0].getType();</div><div class="line">        for (int i = 1; i &lt; clonedChain.length; i++) &#123;</div><div class="line">            if (!certType.equals(clonedChain[i].getType())) &#123;</div><div class="line">                throw new IllegalArgumentException</div><div class="line">                            (&quot;chain does not contain certificates &quot; +</div><div class="line">                            &quot;of the same type&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!privateKey.getAlgorithm().equals</div><div class="line">                    (clonedChain[0].getPublicKey().getAlgorithm())) &#123;</div><div class="line">            throw new IllegalArgumentException</div><div class="line">                            (&quot;private key algorithm does not match &quot; +</div><div class="line">                            &quot;algorithm of public key in end entity &quot; +</div><div class="line">                            &quot;certificate (at index 0)&quot;);</div><div class="line">        &#125;</div><div class="line">        this.privKey = privateKey;</div><div class="line"></div><div class="line">        if (clonedChain[0] instanceof X509Certificate &amp;&amp;</div><div class="line">            !(clonedChain instanceof X509Certificate[])) &#123;</div><div class="line"></div><div class="line">            this.chain = new X509Certificate[clonedChain.length];</div><div class="line">            System.arraycopy(clonedChain, 0,</div><div class="line">                            this.chain, 0, clonedChain.length);</div><div class="line">        &#125; else &#123;</div><div class="line">            this.chain = clonedChain;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.attributes =</div><div class="line">            Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));</div><div class="line">    &#125;</div><div class="line">    public PrivateKey getPrivateKey() &#123;</div><div class="line">        return privKey;</div><div class="line">    &#125;</div><div class="line">    public Certificate[] getCertificateChain() &#123;</div><div class="line">        return chain.clone();</div><div class="line">    &#125;</div><div class="line">    public Certificate getCertificate() &#123;</div><div class="line">        return chain[0];</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Set&lt;Attribute&gt; getAttributes() &#123;</div><div class="line">        return attributes;</div><div class="line">    &#125;</div><div class="line">    public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        sb.append(&quot;Private key entry and certificate chain with &quot;</div><div class="line">            + chain.length + &quot; elements:\r\n&quot;);</div><div class="line">        for (Certificate cert : chain) &#123;</div><div class="line">            sb.append(cert);</div><div class="line">            sb.append(&quot;\r\n&quot;);</div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>KeyStore.SecretKeyEntry</strong><blockquote>
<p>这个存储解构是存储加密过的<strong>SecretKey</strong>，来防止没授权访问。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public static final class SecretKeyEntry implements Entry &#123;</div><div class="line"></div><div class="line">    private final SecretKey sKey;</div><div class="line">    private final Set&lt;Attribute&gt; attributes;</div><div class="line">    public SecretKeyEntry(SecretKey secretKey) &#123;</div><div class="line">        if (secretKey == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;invalid null input&quot;);</div><div class="line">        &#125;</div><div class="line">        this.sKey = secretKey;</div><div class="line">        this.attributes = Collections.&lt;Attribute&gt;emptySet();</div><div class="line">    &#125;</div><div class="line">    public SecretKeyEntry(SecretKey secretKey, Set&lt;Attribute&gt; attributes) &#123;</div><div class="line"></div><div class="line">        if (secretKey == null || attributes == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;invalid null input&quot;);</div><div class="line">        &#125;</div><div class="line">        this.sKey = secretKey;</div><div class="line">        this.attributes =</div><div class="line">            Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));</div><div class="line">    &#125;</div><div class="line">    public SecretKey getSecretKey() &#123;</div><div class="line">        return sKey;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Set&lt;Attribute&gt; getAttributes() &#123;</div><div class="line">        return attributes;</div><div class="line">    &#125;</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Secret key entry with algorithm &quot; + sKey.getAlgorithm();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>KeyStore.TrustedCertificateEntry</strong><blockquote>
<p>这个存储实体包含一个单一的公钥，证书是属于另外的一部分，被叫做可信任证书。因为<strong>StoreKey</strong>的拥有者，对这些证书是已经有明确的身份确认的。通过这类证书实体，我们可以用来实现授权第三方的用户。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public static final class TrustedCertificateEntry implements Entry &#123;</div><div class="line"></div><div class="line">    private final Certificate cert;</div><div class="line">    private final Set&lt;Attribute&gt; attributes;</div><div class="line">    public TrustedCertificateEntry(Certificate trustedCert) &#123;</div><div class="line">        if (trustedCert == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;invalid null input&quot;);</div><div class="line">        &#125;</div><div class="line">        this.cert = trustedCert;</div><div class="line">        this.attributes = Collections.&lt;Attribute&gt;emptySet();</div><div class="line">    &#125;</div><div class="line">    public TrustedCertificateEntry(Certificate trustedCert,</div><div class="line">       Set&lt;Attribute&gt; attributes) &#123;</div><div class="line">        if (trustedCert == null || attributes == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;invalid null input&quot;);</div><div class="line">        &#125;</div><div class="line">        this.cert = trustedCert;</div><div class="line">        this.attributes =</div><div class="line">            Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));</div><div class="line">    &#125;</div><div class="line">    public Certificate getTrustedCertificate() &#123;</div><div class="line">        return cert;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public Set&lt;Attribute&gt; getAttributes() &#123;</div><div class="line">        return attributes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns a string representation of this TrustedCertificateEntry.</div><div class="line">     * @return a string representation of this TrustedCertificateEntry.</div><div class="line">     */</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Trusted certificate entry:\r\n&quot; + cert.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>上述的实体类中，每个Entry都快可以有自己的实体别名。<br>使用KeyStore的一些常用方法：</p>
<ul>
<li><p>依赖于默认类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</div></pre></td></tr></table></figure>
</li>
<li><p>提供一个特殊的KeyStore类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>通过输入流来载入KeyStore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</div><div class="line"></div><div class="line">/** get user password and file input stream*/</div><div class="line">char[] password = getPassword();</div><div class="line"></div><div class="line">try (FileInputStream fis = new FileInputStream(&quot;keyStoreName&quot;)) &#123;</div><div class="line"> ks.load(fis, password);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>构造一个空的KeyStore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">KeyStore.ProtectionParameter protParam =</div><div class="line">    new KeyStore.PasswordProtection(password);</div><div class="line"></div><div class="line">/** get my private key**/</div><div class="line">KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)</div><div class="line">    ks.getEntry(&quot;privateKeyAlias&quot;, protParam);</div><div class="line">PrivateKey myPrivateKey = pkEntry.getPrivateKey();</div><div class="line"></div><div class="line">/** save my secret key**/</div><div class="line">javax.crypto.SecretKey mySecretKey;</div><div class="line">KeyStore.SecretKeyEntry skEntry =</div><div class="line">    new KeyStore.SecretKeyEntry(mySecretKey);</div><div class="line">ks.setEntry(&quot;secretKeyAlias&quot;, skEntry, protParam);</div><div class="line"></div><div class="line">/** store away the keystore**/</div><div class="line">try (FileOutputStream fos = new FileOutputStream(&quot;newKeyStoreName&quot;)) &#123;</div><div class="line">    ks.store(fos, password);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>参考文章：<br><a href="http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）</a><br><a href="http://m635674608.iteye.com/blog/1844777（强推荐）" target="_blank" rel="external">http://m635674608.iteye.com/blog/1844777（强推荐）</a><br><a href="http://joshuasabrina.iteye.com/blog/1798245（强推荐）" target="_blank" rel="external">http://joshuasabrina.iteye.com/blog/1798245（强推荐）</a><br><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）</a><br><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）</a><br><a href="http://www.cnblogs.com/NullPointException/p/5054082.html" target="_blank" rel="external">http://www.cnblogs.com/NullPointException/p/5054082.html</a><br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java.security源码解读系列-总体导读]]></title>
      <url>http://yoursite.com/2016/11/12/jca/01/</url>
      <content type="html"><![CDATA[<blockquote>
<p>导读：</p>
<ul>
<li>这是个人阅读jdk 源码的一个系列，java.security时写的文章，希望写该篇文章，能加深自己对于java语言的理解。</li>
<li>本文相关的JDK版本是JDK7,jdk8</li>
</ul>
</blockquote>
<p>Java平台(Java运行时环境，即JVM + Java API) 在多个层面上提供了security机制，在工作中常用的安全加密一般是采用jdk和spring-security提供的算法。</p>
<h1 id="jdk-中加解密相关类"><a href="#jdk-中加解密相关类" class="headerlink" title="jdk 中加解密相关类"></a>jdk 中加解密相关类</h1><p>java的自带的加解密的算法，主要是由rt.jar下java.security 和 jce.jar（Java Cryptography Extension）加密扩展包下面的类来实现。<br>安全API中包含的各种类和接口为如下这些：</p>
<ul>
<li>java.security中</li>
<li>java.security.spec</li>
<li>java.security.interfaces</li>
<li>javax.crypto</li>
<li>javax.crypto.spec</li>
<li>方法javax.crypto.interfaces<br>通过阅java的加解密源码，目的是为了有经验的程序员，希望创建自己的提供程序包提供加密服务的实现。</li>
</ul>
<h1 id="JCE框架"><a href="#JCE框架" class="headerlink" title="JCE框架"></a>JCE框架</h1><p>jdk自身并没有实现了加解密的主要是jce.jar , jac 主要包括2个软件组件：</p>
<ul>
<li>框架，定义并支持加密服务提供商提供实现。该框架包括软件包，比如rt.jar中的java.security中的类，jce.jar 中的javax.crypto 、javax.crypto.spec javax.interfaces</li>
<li>实际提供了SUNJCE，SunRsaSign, 其中包含实际的加密实现，在sun.security 下有MD5 DSA等加解密的具体实现，在jdk8中发现JCE已经废除使用sun.securit 下的接口了<br>对于JCE的详情，可以参考这篇文章<a href="http://m635674608.iteye.com/blog/1844777" target="_blank" rel="external">http://m635674608.iteye.com/blog/1844777</a></li>
</ul>
<h1 id="阅读源码如何入手"><a href="#阅读源码如何入手" class="headerlink" title="阅读源码如何入手"></a>阅读源码如何入手</h1><p>首先，我要明确自己阅读源码的目的，我这次阅读源码的目的是搞清楚jdk下实现的加解密机制，提供的方法，是我要自定义加解密应该如何实现，虽然不知到自己能不能做到自己实现（尽管有很多加解密的实现了，工作中不提倡轮子，但学习上提倡鲁轮子，so,就硬着头皮上了）。<br>但是，在阅读源码的时候，必须要了解源码的设计背景和理念，不然会不知所措，无从看起，起码对于我这个菜鸟是这样，嘿嘿嘿，自黑一把。<br>为此，我门先要了解JDK源码。<br><img src="http://img.blog.csdn.net/20131204171127140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmJpcmRza3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>我们通常所说的JDK 包，一般是指rt.jar 下的包，其他的jar 包一般是提供商提供的或有SUN公司提供的，里面多多少少或有sun以前的代码影子，毕竟是发明者啊！他们是随时可能被代码重构的，并不能保证jdk的跨平台调用等特性。<br>jdk 下的包，一般会分为：Java.<em>、javax.</em>包，org.*包<br>1、作为J2SE的API公开接口的一部分，与操作系统无关可以在所有Java平台上运行；<br>2、不同的jdk版本会保持兼容不会轻易变化，提供API文档及源码(src.zip)。</p>
<p>sun.<em>包：<br>1、不是API公开接口的一部分，调用sun包的程序并不能确保工作在所有Java平台上，不同的操作系统中的实现可能不相同。<br>2、不同的jdk版本sun包中的类也可能不定期的变化，因此sun.</em>包中的类没有提供API文档及源码。</p>
<blockquote>
<p>注意：平台无关性是Java语言最大的优势之一，从技术上讲，并不能防止你的程序调用sun.<em>包中的类。在JDK版本的变迁当中，这些类可能会被删除或转移到其它包路径下，而且它的接口（包括名称、标签等）也很有可能发生变化，在这种情况下，即便你希望程序仅仅运行在SUN的实现平台下，你仍将承受新的版本给你的系统带来破坏的风险。总之，编写依赖于sun.</em>包的Java程序是不安全的，他们将变得无法移植、破坏了程序的平台无法性、也无法被JDK各版本所兼容。</p>
</blockquote>
<p>javax.*包:<br>是指基于rt.jar 所做的扩展包，一般是由提供商提供。</p>
<p>org.*包：<br>是指由开源社区或非盈利组织提供的源码。这一般很少出现在jdk中。</p>
<h1 id="强大的Security-API"><a href="#强大的Security-API" class="headerlink" title="强大的Security API"></a>强大的Security API</h1><p>在次处，不再罗列出Java core 和JVM提供的一些security相关机制.如private, public, protected, package等安全机制。<br>在这里，重点说说Security API。<br>这套API覆盖了密码相关的功能、PKI (public key infrastructure)、认证(authentication)、安全通信(secure conmmunication)、访问控制(access control)等方方面面。接下来我们将重点介绍这部分的内容。</p>
<h1 id="Basic-Security-Architecture"><a href="#Basic-Security-Architecture" class="headerlink" title="Basic Security Architecture"></a>Basic Security Architecture</h1><p>Security 基础架构<br>java Security API提供了可互操作的算法和安全服务的实现。服务以provider的形式实现，可以以插件的形式植入应用程序中。程序员可以透明地使用这些服务，如此使得程序员可以集中精力在如何把安全组件集成到自己的应用程序中，而不是去实现这些安全功能。此外，除了Java提供的安全服务外，用户可以编写自定义的security provider，按需扩展Java的security平台。<br>扩展Java的security平台的库在许多框架中都有自己的实现。如：spring-security模块中org.springframework.security，这里有具体的实现。</p>
<h1 id="Security-Provider"><a href="#Security-Provider" class="headerlink" title="Security Provider"></a>Security Provider</h1><p>java.security.Provider抽象了Java security provider。它指定了provider的名字，罗列了它实现的安全服务。多个provider可能同时被配置，他们会以优先级排列。当一个安全服务收到请求，这个服务的最高优先级的provider提供服务。<br>应用通过相关的getInstance方法来获得安全服务，比如：调用java.security.MessageDigest的getInstance方法来获得一个message digest 算法(MD5)。<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html" target="_blank" rel="external">例子源于Java官网</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</div></pre></td></tr></table></figure>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html" target="_blank" rel="external">jdk中的Provider者算法</a></p>
<h1 id="Cryptography-Arthitecture-JCA"><a href="#Cryptography-Arthitecture-JCA" class="headerlink" title="Cryptography Arthitecture (JCA)"></a>Cryptography Arthitecture (JCA)</h1><p>密码架构<br>Java的Cryptography架构是一个提供访问和开发密码功能的框架。它提供了许多cryptographic服务：</p>
<ul>
<li>Message digest algorithms 【信息摘要算法, 如：MD5】</li>
<li>Digital signature algorithms 【数字签名算法，DSA】</li>
<li>Symmetric bulk encryption  【对称块加密， 如：DES】</li>
<li>Symmetric stream encryption 【对称流加密， 如：RC4】</li>
<li>Asymmetric encryption 【非对称加密， 如：RSA】</li>
<li>Password-based encryption (PBE) 【密码加密】</li>
<li>Elliptic Curve Cryptography (ECC) 【椭圆曲线加密】</li>
<li>Key agreement algorithms 【key协议算法】</li>
<li>Key generators 【key生成器】</li>
<li>Message Authentication Codes (MACs) 【消息认证码】</li>
<li>(Pseudo-)random number generators 【伪随机数生成器】<br>因为历史原因，Cryptography API位于两个独立的包内：<br>java.security(Signature, MessageDigest)和javax.crypto(Cipher, KeyAgreement)。</li>
</ul>
<p>Java内置的Provider提供了许多通用的密码算法，比如：RSA, DSA, ECDSA等签名算法、DES, AES, ARCFOUR等加密算法、MD5, SHA-1, SHA-256等信息摘要算法、还有Diffie-Hellman和ECDH这样的密钥协商算法。<br>此外，还有一些特殊的provider。</p>
<p>比如SunPKCS11， 它允许Java代码无缝地使用PKCS#11的compliant tokens。<br>在Windows平台上，Java还提供了一些native的Provider去连接本地的 Microsoft CryptoAPI。这个provider的名字叫MSCAPI。它允许Java应用无缝地使用Windows平台的cryptographic service。</p>
<h1 id="Public-Key-Infrastructure-PKI"><a href="#Public-Key-Infrastructure-PKI" class="headerlink" title="Public Key Infrastructure(PKI)"></a>Public Key Infrastructure(PKI)</h1><p>公钥基础构件<br>PKI是一个术语，主要用于描述一类基于公钥的安全信息交互框架。它允许identity，比如人或者组织，绑定在数字证书上，并且提供一种验证证书的方法。PKI包括了密钥、证书、公钥加密和可信的证书颁发机构(CAs，用于生成和签署证书)。<br>Java平台提供API和provider支持X.509、CRLs、PKIX证书路径的构建和验证。PKI相关的类可以在java.security和java.security.cert包下获取。</p>
<p>密钥和证书的仓库<br>Java提供了长期持久化密钥和证书的功能。它通过key store和certificate store来实现。java.security.KeyStore这个类代表了一个key store，一个安全的，用于存储密码和可信证书的仓库。java.security.cert.CertStore类代表了一个certificate store，用于存储不相关的，不受信的证书。同样它可以存储CRLs。<br>Java平台包含标准的PKCS#11和PKCS#12 key store类型，此外还有一个基于文件的key store类型，叫做JKS(Java Key Store)。Java平台内置了一个名叫cacerts的特殊JKS，它为CA证书提供一个默认的密钥库。<br>SunPKCS11(之前在密码架构小节有提过哦)包含了一个PKCS#11的key store实现。这意味着安全硬件(比如：smartcard)的密钥和证书可以被Java应用所使用。<br>此外，Java平台提供了LDAP的certificate store类型用于访问存放在LDAP中的证书。还有一个certificate type用于访问存放在java.util.Collection中的证书。</p>
<p>PKI Tools<br>Java提供了两个内置的工具帮助用户使用密钥，证书和Key store：keytool和jarsigner。<br>keytool用于创建和管理key store。它可以</p>
<ul>
<li>创建公钥私钥对</li>
<li>显示，导入、导出X.509 v1, v2, v3的证书</li>
<li>创建自签名证书</li>
<li>基于证书请求创建证书</li>
<li>导入证书回复(certificate reply)【在外部CA颁发证书之后，会受到一个回复，该回复通常是一个PKCS7编码的证书】</li>
<li>指定公钥证书为可信<br>jarsigner用于给JAR文件签名或者验证已经签名的JAR包。 </li>
</ul>
<h1 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h1><p>认证<br>Authentication是确认用户身份的过程。在Java运行时环境的上下文中，指认证执行Java程序用户的过程。在这种情况下，这个过程依赖于在Cryptography小节描述到的一些服务。</p>
<p>Java平台提供API，用户可以通过插件式的登录模块为应用提供用户认证功能。应用调用LoginContext类(在javax.security.auth.login包内)，它依赖于配置。该配置指定了哪个登录模块(所有登录模块必须实现javax.security.auth.spi.LoginModule接口)为应用提供实际的认证功能。<br>应用只使用标准的LoginContext API， 所以能保持对于底层插件模块的独立性。新的模块可以被无缝地添加到应用中，不需要修改任何的应用代码。如下图：<br><img src="http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/images/3.jpg" alt="image"></p>
<p>Java平台提供了一些内置的登录模块，所有模块都可以再com.sun.security.auth.module包下找到：<br>Krb5LoginModule 【Kerberos认证】<br>JndiLoginModule 【使用LDAP/NIS的用户名/密码认证】<br>KeyStoreLoginModule 【基于Key store的认证】</p>
<h1 id="Secure-Communication"><a href="#Secure-Communication" class="headerlink" title="Secure Communication"></a>Secure Communication</h1><p>安全通信<br>数据走网络，总会通过一些不需要接收该信息的用户。当数据包含一些私人信息时(比如密码，信用卡号等），我们必须采取措施使这些信息不落入未经授权者之手。我们也需要确保数据在传输过程中不被他人篡改。<br>Cryptography(请见Cryptography小节)是安全通讯的基础。Java平台提供了很多API来支持和实现许多标准的安全通讯协议。<br>SSL/TLS<br>对于这部分协议的实现包含了数据加密、数据完整性、服务器认证和客户端认证(可选)功能。用户的应用可以使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">SSL/TLS</a>来为两端提供安全的数据通路。它支持任何应用协议，比如：HTTP。<br>javax.net.ssl.SSLSocket，这个socket类基于普通的stream socket(java.net.Socket)，并封装了SSL/TLS协议功能。此外，你的应用可能需要像New-I/O这样的交替式数据传输功能。javax.net.ssl.SSLEngine类可以帮你生成和解读SSL/TLS数据包。</p>
<p>Java平台还提供API支持插件式(基于Provider)的key manager和trust manager。Key Manager封装在javax.net.ssl.KeyManager内，它管理用于认证的密钥。trust manager封装在javax.net.ssl.TrustManager类中，由它来决断哪个用户是受信的，这基于它自身管理的Key store中的证书。<br>Java平台包含了一个内置的实现了SSL/TLS协议的Provider，它支持如下协议：</p>
<ul>
<li>SSLv3</li>
<li>TLSv1</li>
<li>TLSv1.1</li>
<li>TLSv1.2</li>
</ul>
<p>SASL<br><a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8%E5%B1%82" target="_blank" rel="external">Simple Authentication and Security Layer</a>， SASL定义了认证数据如何被交换，但是它本身并没有指定认证数据的内容。SASL框架可以适用于任何SASL支持的认证机制。目前有很多 标准的SASL机制用于不同的安全级别和部署场景。</p>
<p>用户的应用使用Java的SASL API并不需要强制绑定任何特定的SASL机制，应用可以选择使用自己需要的机制。API支持客户端应用和服务端应用。用户可以使用javax.security.sasl.Sasl类创建SaslClient和SaslServer对象。</p>
<p>SASL机制的实现可以从provider包下找到。每个provider可能提供一个或多个SASL机制。这些provider已经注册到标准的provider架构中，用户可以很方便地使用它们。下面罗列Java平台提供的SASL provider：</p>
<ul>
<li>DRAM-MD5，DIGEST-MD5，EXTERNAL，GSSAPI，NTLM，PLAIN client machanisms <a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8%E5%B1%82" target="_blank" rel="external">【协议相关的说明】</a></li>
<li>DRAM-MD5，DIGEST-MD5，GSSAPI，NTLM server machanisms <a href="http://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%AE%89%E5%85%A8%E5%B1%82" target="_blank" rel="external">【协议相关的说明】</a></li>
</ul>
<p>GSS-API and Kerberos<br>GSS-API, Generic Security Service Application Programming Interface。GSS-API提供应用开发者基于大量底层安全机制的统一安全服务入口。目前，Java的GSS-API需要使用Kerberos v5，而Java已经包含了内置的Kerberos实现。注意，之前介绍的Krb5LoginModule可以结合GSS Kerberos使用。此外，Java平台还有内置的SPNEGO(Simple and Protected GSS API Negotiation Mechanism)的实现。<br>在两个应用使用Java GSS-API安全通信之前，它们必须建立一个共同的安全上下文。上下文封装了共享的状态信息， 比如：密钥。这两个应用都需要创建并使用org.ietf.jgss.GSSContext对象去建立和维护这些共享信息。<br>Java GSS API放在org.ietf.jgss包下。Java平台也定义了基础的Kerberos类，比如KerberosPrinciple，KerberosTicket，KerberosKey和KeyTab。这些类都在javax.security.auth.kerberos包下。</p>
<h1 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h1><p>访问控制<br>Java平台的访问控制架构保护了对敏感资源(比如本地文件)或者应用代码(类的方法)的访问。所有访问控制的决策由security manager(java.lang.SecurityManger类)仲裁。<br>Java Applets和Java Web应用会自动使用SecurityManager。但是，本地的应用如果通过java命令来执行，默认是不会使用SecurityManager的。如果你想在上述情况下使用，那你的应用必须显示地设置它。在Java程序中，你可以调用java.lang.System#setSecurityManager方法来使用SecurityManager，你也可以通过设置参数的方式达成同样的效果：-Djava.security.manager。</p>
<p>权限<br>当Java代码被类加载器加载时，类加载器会为代码自动关联下列信息：</p>
<ul>
<li>代码从哪里加载的</li>
<li>谁签名了该代码(如果有的话)</li>
<li>授权给该代码的默认权限</li>
</ul>
<p>无论代码是从一个不受信的网络下载(比如: applet)还是从本地文件系统加载，以上信息都会关联到你的代码。代码的加载路径由一个URL表示，code signer是signer的证书链。默认的权限为java.security.Permission对象。<br>对于网络下载的代码，默认权限会自动授权代码可以访问下载源的主机。对于本地代码，代码默认有对于代码目录和子目录的访问权限。<br>值得注意的是，在类加载时，系统并不会去验证执行代码的用户身份。如果有必要，应该由应用代码来完成认证的工作(见上文认证小节)。 一旦用户通过认证，应用可以动态地关联运行代码的用户和被执行的代码。这个过程由javax.security.auth.Subject类的doAs方法完成。</p>
<p>策略 (Policy)<br>如上文所述，一个默认权限的有限集在类加载时由类加载器授权给了代码，Admin可以通过安全策略灵活地管理代码权限。<br>Java平台把策略封装在java.security.Policy类中。在任何时间，有且只有一个Policy对象被加载到了Java运行时。这个Policy负责仲裁代码是否可以访问受保护的资源。Policy如何仲裁则依赖于实现。比如，可以使用数据库保存授权信息或者使用一个外部的服务。<br>Java平台提供了默认的策略实现，它从一个或多个ASCII(UTF-8)文件中读取security properties。这些策略文件包含了授权给代码的权限集。这些策略必须符合特定的语法。策略文件可以由简单的文本编辑器或者图形化工具policytool编写。<br>Policy详解，policytool使用方式和例子: 面向Applet, 面向Application</p>
<p>执行访问控制<br>当应用请求访问受限资源时，默认来说，Java会评判整个调用栈来决定程序是否可以访问该资源。<br>如上文所述，资源受SecurityManager保护。Java平台和应用中的安全敏感代码保护着资源访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SecurityManager sm = System.getSecurityManager();  </div><div class="line">if (sm != null) &#123;  </div><div class="line">   sm.checkPermission(perm);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 代码中的perm是Permission对象，比如，要读取/tmp/abc文件，那么Permission对象可以构建如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Permission perm =   </div><div class="line">    new java.io.FilePermission(&quot;/tmp/abc&quot;, &quot;read&quot;);</div></pre></td></tr></table></figure></p>
<p>SecurityManager的默认实现把决策委派给java.security.AccessController的实现。AccessController会遍历调用栈中的每个代码元素的安全策略信息。这些策略基于Admin配置的permission决定请求是否被授权。如果未被授权则跑出java.lang.SecurityException异常。</p>
<p>下图描绘了访问控制的执行过程。在这个特定的例子中，调用栈中有两个元素：ClassA和ClassB。ClassA调用了ClassB的一个方法。这个方法会通过FileInputStream去访问/tmp/abc这个文件。FileInputStream的构造器创建了FilePermission：perm。接着，perm被传递给SecurityManager的checkPermission方法。在本例中，只有ClassA和ClassB的权限需要验证，这是因为，所有的系统代码(FileInputStream,SecurityManager,AccessController)自动获取了所有权限。</p>
<p>从图片中可以看到，ClassA和ClassB加载自不同的路径，并且签名者也不同。它们也可能被授予不同的权限集合。只有这两个类都被授予了访问abc的FilePermission，AccessController才会通过访问abc的请求。<br><img src="http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/images/4.jpg" alt="image"></p>
<h1 id="XML-Signature"><a href="#XML-Signature" class="headerlink" title="XML Signature"></a>XML Signature</h1><p>XML签名<br>Java XML数字签名API用于生成和校验XML的数字签名。XML签名可以应用于任何数据类，XML或者二进制。签名用XML表示。XML签名可以用来保护你的数据并提供数据完整性，消息认证，签名者认证功能。<br>API支持所有的W3C推荐的XML签名语法。API支持扩展和插件形式。它基于Java Cryptography服务provider架构。该API由6个包组成：</p>
<ul>
<li>javax.xml.crypto</li>
<li>javax.xml.crypto.dsig</li>
<li>javax.xml.crypto.dsig.keyinfo</li>
<li>javax.xml.crypto.dsig.spec</li>
<li>javax.xml.crypto.dom</li>
<li>javax.xml.crypto.dsig.dom</li>
</ul>
<blockquote>
<p>参考文章：<br><a href="http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/l-secureclass/index.html（强推荐）</a><br><a href="http://m635674608.iteye.com/blog/1844777（强推荐）" target="_blank" rel="external">http://m635674608.iteye.com/blog/1844777（强推荐）</a><br><a href="http://joshuasabrina.iteye.com/blog/1798245（强推荐）" target="_blank" rel="external">http://joshuasabrina.iteye.com/blog/1798245（强推荐）</a><br><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html（强推荐）</a><br><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/security/overview/jsoverview.html（强推荐）</a><br><a href="http://www.cnblogs.com/NullPointException/p/5054082.html" target="_blank" rel="external">http://www.cnblogs.com/NullPointException/p/5054082.html</a><br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[工作快一年的回望]]></title>
      <url>http://yoursite.com/2016/11/09/2016/11/09/</url>
      <content type="html"><![CDATA[<p>不知不觉，我离开校门参不多快1年了，在出校门后遇到的林林总总，磕磕碰碰，繁琐心事。在蹉跎的工作中，一个毛头小子，初涉社会，不懂世故。<br>想想都是一把心酸泪。不开心的事，就不提了，在这里我说说我大学四年的总结吧，也好给自己一个交代，没白学。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[教你玩博客]]></title>
      <url>http://yoursite.com/2016/11/07/2016/11/07/</url>
      <content type="html"><![CDATA[<p>大家好，我是灯塔下的笔者，很高兴您能访问我的博客。</p>
<h2 id="Quick-Start1"><a href="#Quick-Start1" class="headerlink" title="Quick Start1"></a>Quick Start1</h2><h2 id="Quick-Start2"><a href="#Quick-Start2" class="headerlink" title="Quick Start2"></a>Quick Start2</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/11/06/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>http://yoursite.com/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是張日雄。欢迎来到我的个人技术博客。<br>懂点前端，懂点后端，会点运维，白天上班族，晚上知识的分享者。<br>笔者不是什么技术大牛，写代码也不厉害，只是万花丛中一点绿，但会思考，会努力，要求未来的我比现在的我要好，一位心态阳光的奋斗者。在此总结我的个人成长经验有三点：善于观察、乐于解决问题、善于总结。<br>希望通过该博客总结自己的经验，积累知识。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>http://yoursite.com/reading/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
